/* tslint:disable */
/* eslint-disable */
/**
 * Payroll SMB REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * 
     * @type {RoleType}
     * @memberof Access
     */
    'roleType': RoleType;
    /**
     * 
     * @type {Resource}
     * @memberof Access
     */
    'resource': Resource;
    /**
     * 
     * @type {Action}
     * @memberof Access
     */
    'action': Action;
    /**
     * 
     * @type {Date}
     * @memberof Access
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Access
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Access
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface Accounting
 */
export interface Accounting {
    /**
     * 
     * @type {AccountingType}
     * @memberof Accounting
     */
    'type': AccountingType;
    /**
     * 
     * @type {string}
     * @memberof Accounting
     */
    'name': string;
    /**
     * 
     * @type {Date}
     * @memberof Accounting
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Accounting
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Accounting
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Accounting
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Accounting
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof Accounting
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Accounting
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Accounting
     */
    'id': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AccountingType = {
    Generic: 'generic',
    Kindergarten: 'kindergarten',
    Services: 'services',
    Trade: 'trade',
    Custom: 'custom'
} as const;

export type AccountingType = typeof AccountingType[keyof typeof AccountingType];


/**
 * 
 * @export
 * @enum {string}
 */

export const Action = {
    Create: 'create',
    Read: 'read',
    Update: 'update',
    Delete: 'delete'
} as const;

export type Action = typeof Action[keyof typeof Action];


/**
 * 
 * @export
 * @interface AuthDto
 */
export interface AuthDto {
    /**
     * 
     * @type {string}
     * @memberof AuthDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AuthDto
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthDto
     */
    'rememberMe': boolean;
}
/**
 * 
 * @export
 * @interface AvailableAccessDto
 */
export interface AvailableAccessDto {
    /**
     * 
     * @type {RoleType}
     * @memberof AvailableAccessDto
     */
    'roleType': RoleType;
    /**
     * 
     * @type {Resource}
     * @memberof AvailableAccessDto
     */
    'resource': Resource;
    /**
     * 
     * @type {Action}
     * @memberof AvailableAccessDto
     */
    'action': Action;
}


/**
 * 
 * @export
 * @interface AvailableAccessUserCompanyDto
 */
export interface AvailableAccessUserCompanyDto {
    /**
     * 
     * @type {Resource}
     * @memberof AvailableAccessUserCompanyDto
     */
    'resource': Resource;
    /**
     * 
     * @type {Action}
     * @memberof AvailableAccessUserCompanyDto
     */
    'action': Action;
    /**
     * 
     * @type {string}
     * @memberof AvailableAccessUserCompanyDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof AvailableAccessUserCompanyDto
     */
    'companyId': string;
}


/**
 * 
 * @export
 * @interface AvailableAccessUserDto
 */
export interface AvailableAccessUserDto {
    /**
     * 
     * @type {Resource}
     * @memberof AvailableAccessUserDto
     */
    'resource': Resource;
    /**
     * 
     * @type {Action}
     * @memberof AvailableAccessUserDto
     */
    'action': Action;
    /**
     * 
     * @type {string}
     * @memberof AvailableAccessUserDto
     */
    'userId': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CalcMethod = {
    Salary: 'salary',
    Wage: 'wage',
    Commission: 'commission',
    Allowance: 'allowance',
    PayEveningHours: 'pay_evening_hours',
    PayNightHours: 'pay_night_hours',
    PayOvertime: 'pay_overtime',
    PayWeekendHours: 'pay_weekend_hours',
    PayHolidayHours: 'pay_holiday_hours',
    Bonus: 'bonus',
    PaidVacation: 'paid-vacation',
    UnpaidLeave: 'unpaid-leave',
    UnpaidLeaveCompany: 'unpaid-leave-company',
    PaidSickByCompany: 'paid-sick-by-company',
    PaidSickBySif: 'paid-sick-by-sif',
    UnconfirmedSick: 'unconfirmed-sick',
    IncomeIndexation: 'income-indexation',
    OneTimeAccrual: 'one-time-accrual',
    IncomeTax: 'income-tax',
    MilitaryTax: 'military-tax',
    AdvancePayment: 'advance-payment',
    RegularPayment: 'regular-payment',
    FastPayment: 'fast-payment',
    SifPayment: 'sif-payment',
    OneTimeDeduction: 'one-time-deduction'
} as const;

export type CalcMethod = typeof CalcMethod[keyof typeof CalcMethod];


/**
 * 
 * @export
 * @interface CalcMethodBalanceDto
 */
export interface CalcMethodBalanceDto {
    /**
     * 
     * @type {string}
     * @memberof CalcMethodBalanceDto
     */
    'calcMethod': string;
    /**
     * 
     * @type {number}
     * @memberof CalcMethodBalanceDto
     */
    'factSum': number;
}
/**
 * 
 * @export
 * @interface ClosePayPeriodDto
 */
export interface ClosePayPeriodDto {
    /**
     * 
     * @type {number}
     * @memberof ClosePayPeriodDto
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface Company
 */
export interface Company {
    /**
     * 
     * @type {PaymentSchedule}
     * @memberof Company
     */
    'paymentSchedule': PaymentSchedule;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'taxId': string;
    /**
     * 
     * @type {Law}
     * @memberof Company
     */
    'law'?: Law;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'lawId': string;
    /**
     * 
     * @type {Accounting}
     * @memberof Company
     */
    'accounting'?: Accounting;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'accountingId': string;
    /**
     * 
     * @type {Date}
     * @memberof Company
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof Company
     */
    'dateTo': Date;
    /**
     * 
     * @type {Date}
     * @memberof Company
     */
    'payPeriod': Date;
    /**
     * 
     * @type {Date}
     * @memberof Company
     */
    'checkDate': Date;
    /**
     * 
     * @type {Array<Department>}
     * @memberof Company
     */
    'departments'?: Array<Department>;
    /**
     * 
     * @type {Array<Position>}
     * @memberof Company
     */
    'positions'?: Array<Position>;
    /**
     * 
     * @type {Array<UserCompany>}
     * @memberof Company
     */
    'users'?: Array<UserCompany>;
    /**
     * 
     * @type {Date}
     * @memberof Company
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Company
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Company
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface CreateAccessDto
 */
export interface CreateAccessDto {
    /**
     * 
     * @type {RoleType}
     * @memberof CreateAccessDto
     */
    'roleType': RoleType;
    /**
     * 
     * @type {Resource}
     * @memberof CreateAccessDto
     */
    'resource': Resource;
    /**
     * 
     * @type {Action}
     * @memberof CreateAccessDto
     */
    'action': Action;
}


/**
 * 
 * @export
 * @interface CreateCompanyDto
 */
export interface CreateCompanyDto {
    /**
     * 
     * @type {PaymentSchedule}
     * @memberof CreateCompanyDto
     */
    'paymentSchedule'?: PaymentSchedule;
    /**
     * 
     * @type {string}
     * @memberof CreateCompanyDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCompanyDto
     */
    'lawId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCompanyDto
     */
    'accountingId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCompanyDto
     */
    'taxId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof CreateCompanyDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CreateCompanyDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CreateCompanyDto
     */
    'payPeriod'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CreateCompanyDto
     */
    'checkDate'?: Date;
}


/**
 * 
 * @export
 * @interface CreateDepartmentDto
 */
export interface CreateDepartmentDto {
    /**
     * 
     * @type {string}
     * @memberof CreateDepartmentDto
     */
    'companyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDepartmentDto
     */
    'name'?: string;
    /**
     * 
     * @type {Date}
     * @memberof CreateDepartmentDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CreateDepartmentDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {string}
     * @memberof CreateDepartmentDto
     */
    'parentDepartmentId'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateJobDto
 */
export interface CreateJobDto {
    /**
     * 
     * @type {string}
     * @memberof CreateJobDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateMinWageDto
 */
export interface CreateMinWageDto {
    /**
     * 
     * @type {Date}
     * @memberof CreateMinWageDto
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof CreateMinWageDto
     */
    'dateTo': Date;
    /**
     * 
     * @type {number}
     * @memberof CreateMinWageDto
     */
    'paySum': number;
}
/**
 * 
 * @export
 * @interface CreatePayFundDto
 */
export interface CreatePayFundDto {
    /**
     * 
     * @type {PayFundCategory}
     * @memberof CreatePayFundDto
     */
    'payFundCategory': PayFundCategory;
    /**
     * 
     * @type {string}
     * @memberof CreatePayFundDto
     */
    'positionId': string;
    /**
     * 
     * @type {Date}
     * @memberof CreatePayFundDto
     */
    'payPeriod': Date;
    /**
     * 
     * @type {Date}
     * @memberof CreatePayFundDto
     */
    'accPeriod': Date;
    /**
     * 
     * @type {string}
     * @memberof CreatePayFundDto
     */
    'payFundTypeId': string;
    /**
     * 
     * @type {number}
     * @memberof CreatePayFundDto
     */
    'incomeSum': number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayFundDto
     */
    'baseSum': number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayFundDto
     */
    'rate': number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayFundDto
     */
    'paySum': number;
}


/**
 * 
 * @export
 * @interface CreatePayFundTypeDto
 */
export interface CreatePayFundTypeDto {
    /**
     * 
     * @type {PayFundGroup}
     * @memberof CreatePayFundTypeDto
     */
    'group': PayFundGroup;
    /**
     * 
     * @type {PayFundCalcMethod}
     * @memberof CreatePayFundTypeDto
     */
    'calcMethod': PayFundCalcMethod;
    /**
     * 
     * @type {string}
     * @memberof CreatePayFundTypeDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreatePayFundTypeDto
     */
    'sequence': number;
    /**
     * 
     * @type {string}
     * @memberof CreatePayFundTypeDto
     */
    'description': string;
}


/**
 * 
 * @export
 * @interface CreatePayPeriodDto
 */
export interface CreatePayPeriodDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePayPeriodDto
     */
    'companyId': string;
    /**
     * 
     * @type {Date}
     * @memberof CreatePayPeriodDto
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof CreatePayPeriodDto
     */
    'dateTo': Date;
    /**
     * 
     * @type {string}
     * @memberof CreatePayPeriodDto
     */
    'state': string;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'inBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'inCompanyDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'inEmployeeDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'accruals'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'deductions'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'basic'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'adjustments'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'bonuses'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'vacations'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'sicks'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'refunds'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'otherAccruals'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'taxes'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'payments'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'otherDeductions'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'outBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'outCompanyDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'outEmployeeDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayPeriodDto
     */
    'funds'?: number;
}
/**
 * 
 * @export
 * @interface CreatePaymentDto
 */
export interface CreatePaymentDto {
    /**
     * 
     * @type {PaymentStatus}
     * @memberof CreatePaymentDto
     */
    'status'?: PaymentStatus;
    /**
     * 
     * @type {RecordFlags}
     * @memberof CreatePaymentDto
     */
    'recordFlags'?: RecordFlags;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentDto
     */
    'companyId': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentDto
     */
    'paymentTypeId': string;
    /**
     * 
     * @type {Date}
     * @memberof CreatePaymentDto
     */
    'payPeriod'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CreatePaymentDto
     */
    'accPeriod'?: Date;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentDto
     */
    'docNumber'?: string;
    /**
     * 
     * @type {Date}
     * @memberof CreatePaymentDto
     */
    'docDate'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CreatePaymentDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CreatePaymentDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentDto
     */
    'baseSum'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentDto
     */
    'deductions'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentDto
     */
    'paySum'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentDto
     */
    'funds'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentDto
     */
    'description'?: string;
}


/**
 * 
 * @export
 * @interface CreatePaymentPositionDto
 */
export interface CreatePaymentPositionDto {
    /**
     * 
     * @type {RecordFlags}
     * @memberof CreatePaymentPositionDto
     */
    'recordFlags'?: RecordFlags;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentPositionDto
     */
    'paymentId': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentPositionDto
     */
    'positionId': string;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentPositionDto
     */
    'baseSum'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentPositionDto
     */
    'deductions'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentPositionDto
     */
    'paySum'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentPositionDto
     */
    'funds'?: number;
}


/**
 * 
 * @export
 * @interface CreatePaymentTypeDto
 */
export interface CreatePaymentTypeDto {
    /**
     * 
     * @type {PaymentPart}
     * @memberof CreatePaymentTypeDto
     */
    'paymentPart': PaymentPart;
    /**
     * 
     * @type {PaymentGroup}
     * @memberof CreatePaymentTypeDto
     */
    'paymentGroup': PaymentGroup;
    /**
     * 
     * @type {CalcMethod}
     * @memberof CreatePaymentTypeDto
     */
    'calcMethod': CalcMethod;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentTypeDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentTypeDto
     */
    'description'?: string;
}


/**
 * 
 * @export
 * @interface CreatePayrollDto
 */
export interface CreatePayrollDto {
    /**
     * 
     * @type {RecordFlags}
     * @memberof CreatePayrollDto
     */
    'recordFlags': RecordFlags;
    /**
     * 
     * @type {Resource}
     * @memberof CreatePayrollDto
     */
    'sourceType'?: Resource;
    /**
     * 
     * @type {FixedFlags}
     * @memberof CreatePayrollDto
     */
    'fixedFlags'?: FixedFlags;
    /**
     * 
     * @type {string}
     * @memberof CreatePayrollDto
     */
    'positionId': string;
    /**
     * 
     * @type {Date}
     * @memberof CreatePayrollDto
     */
    'payPeriod': Date;
    /**
     * 
     * @type {Date}
     * @memberof CreatePayrollDto
     */
    'accPeriod': Date;
    /**
     * 
     * @type {string}
     * @memberof CreatePayrollDto
     */
    'paymentTypeId': string;
    /**
     * 
     * @type {Date}
     * @memberof CreatePayrollDto
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof CreatePayrollDto
     */
    'dateTo': Date;
    /**
     * 
     * @type {number}
     * @memberof CreatePayrollDto
     */
    'factSum': number;
    /**
     * 
     * @type {Position}
     * @memberof CreatePayrollDto
     */
    'position'?: Position;
    /**
     * 
     * @type {string}
     * @memberof CreatePayrollDto
     */
    'sourceId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof CreatePayrollDto
     */
    'dateBegin'?: Date | null;
    /**
     * 
     * @type {Date}
     * @memberof CreatePayrollDto
     */
    'dateEnd'?: Date | null;
    /**
     * 
     * @type {number}
     * @memberof CreatePayrollDto
     */
    'planDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayrollDto
     */
    'planHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayrollDto
     */
    'planSum'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayrollDto
     */
    'rate'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayrollDto
     */
    'factDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayrollDto
     */
    'factHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayrollDto
     */
    'mask1'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePayrollDto
     */
    'mask2'?: number;
    /**
     * 
     * @type {object}
     * @memberof CreatePayrollDto
     */
    'planHoursByDay'?: object | null;
    /**
     * 
     * @type {object}
     * @memberof CreatePayrollDto
     */
    'factHoursByDay'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePayrollDto
     */
    'parentId'?: string | null;
}


/**
 * 
 * @export
 * @interface CreatePersonDto
 */
export interface CreatePersonDto {
    /**
     * 
     * @type {Sex}
     * @memberof CreatePersonDto
     */
    'sex'?: Sex;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonDto
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonDto
     */
    'fullName'?: string;
    /**
     * 
     * @type {Date}
     * @memberof CreatePersonDto
     */
    'birthday'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonDto
     */
    'taxId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonDto
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonDto
     */
    'photo'?: string;
}


/**
 * 
 * @export
 * @interface CreatePositionDto
 */
export interface CreatePositionDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePositionDto
     */
    'companyId': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePositionDto
     */
    'cardNumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreatePositionDto
     */
    'sequenceNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreatePositionDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePositionDto
     */
    'personId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof CreatePositionDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CreatePositionDto
     */
    'dateTo'?: Date;
}
/**
 * 
 * @export
 * @interface CreatePositionHistoryDto
 */
export interface CreatePositionHistoryDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePositionHistoryDto
     */
    'positionId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof CreatePositionHistoryDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CreatePositionHistoryDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {string}
     * @memberof CreatePositionHistoryDto
     */
    'departmentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePositionHistoryDto
     */
    'jobId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePositionHistoryDto
     */
    'workTimeNormId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePositionHistoryDto
     */
    'paymentTypeId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreatePositionHistoryDto
     */
    'wage'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePositionHistoryDto
     */
    'rate'?: number;
}
/**
 * 
 * @export
 * @interface CreateRoleDto
 */
export interface CreateRoleDto {
    /**
     * 
     * @type {RoleType}
     * @memberof CreateRoleDto
     */
    'type': RoleType;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleDto
     */
    'name': string;
}


/**
 * 
 * @export
 * @interface CreateTaskDto
 */
export interface CreateTaskDto {
    /**
     * 
     * @type {TaskType}
     * @memberof CreateTaskDto
     */
    'type': TaskType;
    /**
     * 
     * @type {TaskStatus}
     * @memberof CreateTaskDto
     */
    'status': TaskStatus;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'companyId': string;
    /**
     * 
     * @type {Date}
     * @memberof CreateTaskDto
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof CreateTaskDto
     */
    'dateTo': Date;
    /**
     * 
     * @type {number}
     * @memberof CreateTaskDto
     */
    'sequenceNumber': number;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'entityId': string | null;
}


/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'roleId': string;
}
/**
 * 
 * @export
 * @interface CreateWorkTimeNormDto
 */
export interface CreateWorkTimeNormDto {
    /**
     * 
     * @type {WorkTimeNormType}
     * @memberof CreateWorkTimeNormDto
     */
    'type': WorkTimeNormType;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTimeNormDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTimeNormDto
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTimeNormDto
     */
    'description'?: string;
    /**
     * 
     * @type {Date}
     * @memberof CreateWorkTimeNormDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CreateWorkTimeNormDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWorkTimeNormDto
     */
    'applyHolidays'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWorkTimeNormDto
     */
    'applyShortenedDays'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWorkTimeNormDto
     */
    'applyMovedDays'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWorkTimeNormDto
     */
    'applyPhases'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWorkTimeNormDto
     */
    'applyRate'?: boolean;
}


/**
 * 
 * @export
 * @interface Department
 */
export interface Department {
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'name': string;
    /**
     * 
     * @type {Company}
     * @memberof Department
     */
    'company'?: Company;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'companyId': string;
    /**
     * 
     * @type {Date}
     * @memberof Department
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof Department
     */
    'dateTo': Date;
    /**
     * 
     * @type {Department}
     * @memberof Department
     */
    'parentDepartment'?: Department | null;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'parentDepartmentId'?: string | null;
    /**
     * 
     * @type {Array<Department>}
     * @memberof Department
     */
    'childDepartments'?: Array<Department>;
    /**
     * 
     * @type {Date}
     * @memberof Department
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Department
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Department
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Department
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface FindAllDepartmentDto
 */
export interface FindAllDepartmentDto {
    /**
     * 
     * @type {boolean}
     * @memberof FindAllDepartmentDto
     */
    'relations'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FindAllDepartmentDto
     */
    'companyId': string;
}
/**
 * 
 * @export
 * @interface FindAllPayPeriodDto
 */
export interface FindAllPayPeriodDto {
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPayPeriodDto
     */
    'relations'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPayPeriodDto
     */
    'fullFieldList'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FindAllPayPeriodDto
     */
    'companyId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof FindAllPayPeriodDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FindAllPayPeriodDto
     */
    'dateTo'?: Date;
}
/**
 * 
 * @export
 * @interface FindAllPaymentDto
 */
export interface FindAllPaymentDto {
    /**
     * 
     * @type {string}
     * @memberof FindAllPaymentDto
     */
    'companyId': string;
    /**
     * 
     * @type {string}
     * @memberof FindAllPaymentDto
     */
    'positionId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof FindAllPaymentDto
     */
    'payPeriod'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FindAllPaymentDto
     */
    'accPeriod'?: Date;
    /**
     * 
     * @type {string}
     * @memberof FindAllPaymentDto
     */
    'paymentTypeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindAllPaymentDto
     */
    'status'?: FindAllPaymentDtoStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPaymentDto
     */
    'relations'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPaymentDto
     */
    'withDeleted'?: boolean;
}

export const FindAllPaymentDtoStatusEnum = {
    Draft: 'draft',
    Submitted: 'submitted',
    Accepted: 'accepted',
    Paid: 'paid'
} as const;

export type FindAllPaymentDtoStatusEnum = typeof FindAllPaymentDtoStatusEnum[keyof typeof FindAllPaymentDtoStatusEnum];

/**
 * 
 * @export
 * @interface FindAllPaymentPositionDto
 */
export interface FindAllPaymentPositionDto {
    /**
     * 
     * @type {string}
     * @memberof FindAllPaymentPositionDto
     */
    'paymentId': string;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPaymentPositionDto
     */
    'relations'?: boolean;
}
/**
 * 
 * @export
 * @interface FindAllPaymentTypeDto
 */
export interface FindAllPaymentTypeDto {
    /**
     * 
     * @type {string}
     * @memberof FindAllPaymentTypeDto
     */
    'part'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindAllPaymentTypeDto
     */
    'groups'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindAllPaymentTypeDto
     */
    'methods'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof FindAllPaymentTypeDto
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface FindAllPositionBalanceDto
 */
export interface FindAllPositionBalanceDto {
    /**
     * 
     * @type {string}
     * @memberof FindAllPositionBalanceDto
     */
    'companyId': string;
    /**
     * 
     * @type {Date}
     * @memberof FindAllPositionBalanceDto
     */
    'payPeriod'?: Date;
}
/**
 * 
 * @export
 * @interface FindAllPositionDto
 */
export interface FindAllPositionDto {
    /**
     * 
     * @type {string}
     * @memberof FindAllPositionDto
     */
    'companyId': string;
    /**
     * 
     * @type {Date}
     * @memberof FindAllPositionDto
     */
    'onDate'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FindAllPositionDto
     */
    'onPayPeriodDate'?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPositionDto
     */
    'relations'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPositionDto
     */
    'employeesOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPositionDto
     */
    'vacanciesOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPositionDto
     */
    'dismissedOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPositionDto
     */
    'deletedOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPositionDto
     */
    'includeDeleted'?: boolean;
}
/**
 * 
 * @export
 * @interface FindAllPositionHistoryDto
 */
export interface FindAllPositionHistoryDto {
    /**
     * 
     * @type {Date}
     * @memberof FindAllPositionHistoryDto
     */
    'onDate'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FindAllPositionHistoryDto
     */
    'onPayPeriodDate'?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPositionHistoryDto
     */
    'last'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllPositionHistoryDto
     */
    'relations'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FindAllPositionHistoryDto
     */
    'positionId': string;
}
/**
 * 
 * @export
 * @interface FindAllTaskDto
 */
export interface FindAllTaskDto {
    /**
     * 
     * @type {string}
     * @memberof FindAllTaskDto
     */
    'companyId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof FindAllTaskDto
     */
    'onDate'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FindAllTaskDto
     */
    'onPayPeriodDate'?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllTaskDto
     */
    'relations'?: boolean;
}
/**
 * 
 * @export
 * @interface FindAllUserCompanyDto
 */
export interface FindAllUserCompanyDto {
    /**
     * 
     * @type {string}
     * @memberof FindAllUserCompanyDto
     */
    'userId': string;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllUserCompanyDto
     */
    'relations'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllUserCompanyDto
     */
    'withDeleted'?: boolean;
}
/**
 * 
 * @export
 * @interface FindCurrentPayPeriodDto
 */
export interface FindCurrentPayPeriodDto {
    /**
     * 
     * @type {boolean}
     * @memberof FindCurrentPayPeriodDto
     */
    'relations'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindCurrentPayPeriodDto
     */
    'fullFieldList'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FindCurrentPayPeriodDto
     */
    'companyId'?: string;
}
/**
 * 
 * @export
 * @interface FindOneDepartmentDto
 */
export interface FindOneDepartmentDto {
    /**
     * 
     * @type {boolean}
     * @memberof FindOneDepartmentDto
     */
    'relations'?: boolean;
}
/**
 * 
 * @export
 * @interface FindOnePayPeriodDto
 */
export interface FindOnePayPeriodDto {
    /**
     * 
     * @type {boolean}
     * @memberof FindOnePayPeriodDto
     */
    'relations'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindOnePayPeriodDto
     */
    'fullFieldList'?: boolean;
}
/**
 * 
 * @export
 * @interface FindOnePaymentDto
 */
export interface FindOnePaymentDto {
    /**
     * 
     * @type {boolean}
     * @memberof FindOnePaymentDto
     */
    'relations'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindOnePaymentDto
     */
    'withDeleted'?: boolean;
}
/**
 * 
 * @export
 * @interface FindOnePaymentPositionDto
 */
export interface FindOnePaymentPositionDto {
    /**
     * 
     * @type {boolean}
     * @memberof FindOnePaymentPositionDto
     */
    'relations'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindOnePaymentPositionDto
     */
    'withDeleted'?: boolean;
}
/**
 * 
 * @export
 * @interface FindOnePositionDto
 */
export interface FindOnePositionDto {
    /**
     * 
     * @type {Date}
     * @memberof FindOnePositionDto
     */
    'onDate'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FindOnePositionDto
     */
    'onPayPeriodDate'?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof FindOnePositionDto
     */
    'relations'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindOnePositionDto
     */
    'withDeleted'?: boolean;
}
/**
 * 
 * @export
 * @interface FindOnePositionHistoryDto
 */
export interface FindOnePositionHistoryDto {
    /**
     * 
     * @type {boolean}
     * @memberof FindOnePositionHistoryDto
     */
    'relations'?: boolean;
}
/**
 * 
 * @export
 * @interface FindOneTaskDto
 */
export interface FindOneTaskDto {
    /**
     * 
     * @type {boolean}
     * @memberof FindOneTaskDto
     */
    'relations'?: boolean;
}
/**
 * 
 * @export
 * @interface FindOneUserCompanyDto
 */
export interface FindOneUserCompanyDto {
    /**
     * 
     * @type {boolean}
     * @memberof FindOneUserCompanyDto
     */
    'relations'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindOneUserCompanyDto
     */
    'withDeleted'?: boolean;
}
/**
 * 
 * @export
 * @interface FindOneUserDto
 */
export interface FindOneUserDto {
    /**
     * 
     * @type {boolean}
     * @memberof FindOneUserDto
     */
    'relations'?: boolean;
}
/**
 * 
 * @export
 * @interface FindPayFundDto
 */
export interface FindPayFundDto {
    /**
     * 
     * @type {string}
     * @memberof FindPayFundDto
     */
    'companyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindPayFundDto
     */
    'positionId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof FindPayFundDto
     */
    'payPeriod'?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof FindPayFundDto
     */
    'relations'?: boolean;
}
/**
 * 
 * @export
 * @interface FindPayrollDto
 */
export interface FindPayrollDto {
    /**
     * 
     * @type {string}
     * @memberof FindPayrollDto
     */
    'companyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindPayrollDto
     */
    'positionId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof FindPayrollDto
     */
    'payPeriod'?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof FindPayrollDto
     */
    'relations'?: boolean;
}
/**
 * 
 * @export
 * @interface FindPositionByPersonDto
 */
export interface FindPositionByPersonDto {
    /**
     * 
     * @type {string}
     * @memberof FindPositionByPersonDto
     */
    'companyId': string;
    /**
     * 
     * @type {string}
     * @memberof FindPositionByPersonDto
     */
    'personId': string;
    /**
     * 
     * @type {Date}
     * @memberof FindPositionByPersonDto
     */
    'onDate'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FindPositionByPersonDto
     */
    'onPayPeriodDate'?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof FindPositionByPersonDto
     */
    'relations'?: boolean;
}
/**
 * 
 * @export
 * @interface FindWorkTimeNormDto
 */
export interface FindWorkTimeNormDto {
    /**
     * 
     * @type {boolean}
     * @memberof FindWorkTimeNormDto
     */
    'relations'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FixedFlags = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_4: 4,
    NUMBER_8: 8,
    NUMBER_16: 16,
    NUMBER_32: 32,
    NUMBER_64: 64
} as const;

export type FixedFlags = typeof FixedFlags[keyof typeof FixedFlags];


/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'name': string;
    /**
     * 
     * @type {Date}
     * @memberof Job
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Job
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Job
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Law
 */
export interface Law {
    /**
     * 
     * @type {LawType}
     * @memberof Law
     */
    'type': LawType;
    /**
     * 
     * @type {string}
     * @memberof Law
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Law
     */
    'name': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const LawType = {
    Ukraine: 'ukraine',
    Custom: 'custom'
} as const;

export type LawType = typeof LawType[keyof typeof LawType];


/**
 * 
 * @export
 * @interface MessageEvent
 */
export interface MessageEvent {
    /**
     * 
     * @type {ServerEvent}
     * @memberof MessageEvent
     */
    'data': ServerEvent;
}


/**
 * 
 * @export
 * @interface MinWage
 */
export interface MinWage {
    /**
     * 
     * @type {Date}
     * @memberof MinWage
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof MinWage
     */
    'dateTo': Date;
    /**
     * 
     * @type {number}
     * @memberof MinWage
     */
    'paySum': number;
    /**
     * 
     * @type {Date}
     * @memberof MinWage
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof MinWage
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof MinWage
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof MinWage
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof MinWage
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof MinWage
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MinWage
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof MinWage
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface OpenPayPeriodDto
 */
export interface OpenPayPeriodDto {
    /**
     * 
     * @type {number}
     * @memberof OpenPayPeriodDto
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface PayFund
 */
export interface PayFund {
    /**
     * 
     * @type {PayFundCategory}
     * @memberof PayFund
     */
    'payFundCategory': PayFundCategory;
    /**
     * 
     * @type {string}
     * @memberof PayFund
     */
    'id': string;
    /**
     * 
     * @type {Position}
     * @memberof PayFund
     */
    'position'?: Position;
    /**
     * 
     * @type {string}
     * @memberof PayFund
     */
    'positionId': string;
    /**
     * 
     * @type {Date}
     * @memberof PayFund
     */
    'payPeriod': Date;
    /**
     * 
     * @type {Date}
     * @memberof PayFund
     */
    'accPeriod': Date;
    /**
     * 
     * @type {PayFundType}
     * @memberof PayFund
     */
    'payFundType'?: PayFundType;
    /**
     * 
     * @type {string}
     * @memberof PayFund
     */
    'payFundTypeId': string;
    /**
     * 
     * @type {number}
     * @memberof PayFund
     */
    'incomeSum': number;
    /**
     * 
     * @type {number}
     * @memberof PayFund
     */
    'baseSum': number;
    /**
     * 
     * @type {number}
     * @memberof PayFund
     */
    'rate': number;
    /**
     * 
     * @type {number}
     * @memberof PayFund
     */
    'paySum': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PayFundCalcMethod = {
    EcbVacation: 'ECB-vacation',
    EcbSalary: 'ECB-salary',
    EcbCommission: 'ECB-commission',
    EcbSickByCompany: 'ECB-sick-by-company',
    EcbSickBySif: 'ECB-sick-by-SIF',
    EcbMaternity: 'ECB-maternity',
    EcbMinWage: 'ECB-min-wage',
    Custom: 'custom'
} as const;

export type PayFundCalcMethod = typeof PayFundCalcMethod[keyof typeof PayFundCalcMethod];


/**
 * 
 * @export
 * @enum {string}
 */

export const PayFundCategory = {
    Employees: 'employees',
    Invalidity: 'invalidity',
    Maternity: 'maternity',
    Government: 'government'
} as const;

export type PayFundCategory = typeof PayFundCategory[keyof typeof PayFundCategory];


/**
 * 
 * @export
 * @enum {string}
 */

export const PayFundGroup = {
    Ecb: 'ECB',
    Custom: 'custom'
} as const;

export type PayFundGroup = typeof PayFundGroup[keyof typeof PayFundGroup];


/**
 * 
 * @export
 * @interface PayFundType
 */
export interface PayFundType {
    /**
     * 
     * @type {PayFundGroup}
     * @memberof PayFundType
     */
    'group': PayFundGroup;
    /**
     * 
     * @type {PayFundCalcMethod}
     * @memberof PayFundType
     */
    'calcMethod': PayFundCalcMethod;
    /**
     * 
     * @type {string}
     * @memberof PayFundType
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PayFundType
     */
    'sequence': number;
    /**
     * 
     * @type {string}
     * @memberof PayFundType
     */
    'description': string;
    /**
     * 
     * @type {Date}
     * @memberof PayFundType
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof PayFundType
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof PayFundType
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof PayFundType
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof PayFundType
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof PayFundType
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayFundType
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof PayFundType
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface PayPeriod
 */
export interface PayPeriod {
    /**
     * 
     * @type {Company}
     * @memberof PayPeriod
     */
    'company'?: Company;
    /**
     * 
     * @type {string}
     * @memberof PayPeriod
     */
    'companyId': string;
    /**
     * 
     * @type {Date}
     * @memberof PayPeriod
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof PayPeriod
     */
    'dateTo': Date;
    /**
     * 
     * @type {string}
     * @memberof PayPeriod
     */
    'state': string;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'inBalance': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'inCompanyDebt': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'inEmployeeDebt': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'accruals': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'deductions': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'basic': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'adjustments': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'bonuses': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'vacations': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'sicks': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'refunds': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'otherAccruals': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'taxes': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'payments': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'otherDeductions': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'outBalance': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'outCompanyDebt': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'outEmployeeDebt': number;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'funds': number;
    /**
     * 
     * @type {Array<PayPeriodSummary>}
     * @memberof PayPeriod
     */
    'calcMethods'?: Array<PayPeriodSummary>;
    /**
     * 
     * @type {Date}
     * @memberof PayPeriod
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof PayPeriod
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof PayPeriod
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof PayPeriod
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof PayPeriod
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof PayPeriod
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayPeriod
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof PayPeriod
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface PayPeriodSummary
 */
export interface PayPeriodSummary {
    /**
     * 
     * @type {CalcMethod}
     * @memberof PayPeriodSummary
     */
    'calcMethod': CalcMethod;
    /**
     * 
     * @type {string}
     * @memberof PayPeriodSummary
     */
    'id': string;
    /**
     * 
     * @type {PayPeriod}
     * @memberof PayPeriodSummary
     */
    'payPeriod'?: PayPeriod;
    /**
     * 
     * @type {string}
     * @memberof PayPeriodSummary
     */
    'payPeriodId': string;
    /**
     * 
     * @type {number}
     * @memberof PayPeriodSummary
     */
    'factSum': number;
}


/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {PaymentStatus}
     * @memberof Payment
     */
    'status': PaymentStatus;
    /**
     * 
     * @type {RecordFlags}
     * @memberof Payment
     */
    'recordFlags': RecordFlags;
    /**
     * 
     * @type {Company}
     * @memberof Payment
     */
    'company'?: Company;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'companyId': string;
    /**
     * 
     * @type {Date}
     * @memberof Payment
     */
    'payPeriod': Date;
    /**
     * 
     * @type {Date}
     * @memberof Payment
     */
    'accPeriod': Date;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'docNumber': string;
    /**
     * 
     * @type {Date}
     * @memberof Payment
     */
    'docDate': Date;
    /**
     * 
     * @type {PaymentType}
     * @memberof Payment
     */
    'paymentType'?: PaymentType;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'paymentTypeId': string;
    /**
     * 
     * @type {Date}
     * @memberof Payment
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof Payment
     */
    'dateTo': Date;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'baseSum': number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'deductions': number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'paySum': number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'funds': number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'description': string;
    /**
     * 
     * @type {Array<PaymentPosition>}
     * @memberof Payment
     */
    'paymentPositions'?: Array<PaymentPosition>;
    /**
     * 
     * @type {Date}
     * @memberof Payment
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Payment
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Payment
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'id': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentGroup = {
    Basic: 'basic',
    Adjustments: 'adjustments',
    Bonuses: 'bonuses',
    Vacations: 'vacations',
    Sicks: 'sicks',
    Refunds: 'refunds',
    OtherAccruals: 'other-accruals',
    Taxes: 'taxes',
    Payments: 'payments',
    OtherDeductions: 'other-deductions'
} as const;

export type PaymentGroup = typeof PaymentGroup[keyof typeof PaymentGroup];


/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentPart = {
    Accruals: 'accruals',
    Deductions: 'deductions'
} as const;

export type PaymentPart = typeof PaymentPart[keyof typeof PaymentPart];


/**
 * 
 * @export
 * @interface PaymentPosition
 */
export interface PaymentPosition {
    /**
     * 
     * @type {RecordFlags}
     * @memberof PaymentPosition
     */
    'recordFlags': RecordFlags;
    /**
     * 
     * @type {Payment}
     * @memberof PaymentPosition
     */
    'payment'?: Payment;
    /**
     * 
     * @type {string}
     * @memberof PaymentPosition
     */
    'paymentId': string;
    /**
     * 
     * @type {Position}
     * @memberof PaymentPosition
     */
    'position'?: Position;
    /**
     * 
     * @type {string}
     * @memberof PaymentPosition
     */
    'positionId': string;
    /**
     * 
     * @type {number}
     * @memberof PaymentPosition
     */
    'baseSum': number;
    /**
     * 
     * @type {number}
     * @memberof PaymentPosition
     */
    'deductions': number;
    /**
     * 
     * @type {number}
     * @memberof PaymentPosition
     */
    'paySum': number;
    /**
     * 
     * @type {number}
     * @memberof PaymentPosition
     */
    'funds': number;
    /**
     * 
     * @type {Date}
     * @memberof PaymentPosition
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof PaymentPosition
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof PaymentPosition
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof PaymentPosition
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof PaymentPosition
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentPosition
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentPosition
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentPosition
     */
    'id': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentSchedule = {
    Every15Day: 'every-15-day',
    LastDay: 'last-day',
    NextMonth: 'next-month'
} as const;

export type PaymentSchedule = typeof PaymentSchedule[keyof typeof PaymentSchedule];


/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentStatus = {
    Draft: 'draft',
    Submitted: 'submitted',
    Accepted: 'accepted',
    Paid: 'paid'
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


/**
 * 
 * @export
 * @interface PaymentType
 */
export interface PaymentType {
    /**
     * 
     * @type {PaymentPart}
     * @memberof PaymentType
     */
    'paymentPart': PaymentPart;
    /**
     * 
     * @type {PaymentGroup}
     * @memberof PaymentType
     */
    'paymentGroup': PaymentGroup;
    /**
     * 
     * @type {CalcMethod}
     * @memberof PaymentType
     */
    'calcMethod': CalcMethod;
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    'description': string;
    /**
     * 
     * @type {Date}
     * @memberof PaymentType
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof PaymentType
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof PaymentType
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentType
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface Payroll
 */
export interface Payroll {
    /**
     * 
     * @type {Resource}
     * @memberof Payroll
     */
    'sourceType': Resource;
    /**
     * 
     * @type {RecordFlags}
     * @memberof Payroll
     */
    'recordFlags': RecordFlags;
    /**
     * 
     * @type {FixedFlags}
     * @memberof Payroll
     */
    'fixedFlags': FixedFlags;
    /**
     * 
     * @type {Position}
     * @memberof Payroll
     */
    'position'?: Position;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'positionId': string;
    /**
     * 
     * @type {Date}
     * @memberof Payroll
     */
    'payPeriod': Date;
    /**
     * 
     * @type {Date}
     * @memberof Payroll
     */
    'accPeriod': Date;
    /**
     * 
     * @type {PaymentType}
     * @memberof Payroll
     */
    'paymentType'?: PaymentType;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'paymentTypeId': string;
    /**
     * 
     * @type {Date}
     * @memberof Payroll
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof Payroll
     */
    'dateTo': Date;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'sourceId': string | null;
    /**
     * 
     * @type {Date}
     * @memberof Payroll
     */
    'dateBegin': Date | null;
    /**
     * 
     * @type {Date}
     * @memberof Payroll
     */
    'dateEnd': Date | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'planDays': number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'planHours': number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'planSum': number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'rate': number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'factDays': number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'factHours': number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'factSum': number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'mask1': number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'mask2': number;
    /**
     * 
     * @type {object}
     * @memberof Payroll
     */
    'planHoursByDay': object | null;
    /**
     * 
     * @type {object}
     * @memberof Payroll
     */
    'factHoursByDay': object | null;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'parentId': string | null;
    /**
     * 
     * @type {Date}
     * @memberof Payroll
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Payroll
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Payroll
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface Person
 */
export interface Person {
    /**
     * 
     * @type {Sex}
     * @memberof Person
     */
    'sex': Sex;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'middleName': string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'fullName': string;
    /**
     * 
     * @type {Date}
     * @memberof Person
     */
    'birthday': Date | null;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'taxId': string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'photo': string;
    /**
     * 
     * @type {Array<Position>}
     * @memberof Person
     */
    'positions'?: Array<Position>;
    /**
     * 
     * @type {Date}
     * @memberof Person
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Person
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Person
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Person
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {Company}
     * @memberof Position
     */
    'company'?: Company;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'companyId': string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'cardNumber': string;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'sequenceNumber': number;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'description': string;
    /**
     * 
     * @type {Person}
     * @memberof Position
     */
    'person'?: Person;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'personId': string | null;
    /**
     * 
     * @type {Date}
     * @memberof Position
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof Position
     */
    'dateTo': Date;
    /**
     * 
     * @type {Array<PositionHistory>}
     * @memberof Position
     */
    'history'?: Array<PositionHistory>;
    /**
     * 
     * @type {Array<PositionBalance>}
     * @memberof Position
     */
    'balance'?: Array<PositionBalance>;
    /**
     * 
     * @type {Date}
     * @memberof Position
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Position
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Position
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface PositionBalance
 */
export interface PositionBalance {
    /**
     * 
     * @type {string}
     * @memberof PositionBalance
     */
    'id': string;
    /**
     * 
     * @type {Position}
     * @memberof PositionBalance
     */
    'position'?: Position;
    /**
     * 
     * @type {string}
     * @memberof PositionBalance
     */
    'positionId': string;
    /**
     * 
     * @type {Date}
     * @memberof PositionBalance
     */
    'payPeriod': Date;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'inBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'planDays': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'planHours': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'factDays': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'factHours': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'accruals': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'deductions': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'basic': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'adjustments': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'bonuses': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'vacations': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'sicks': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'refunds': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'otherAccruals': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'taxes': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'payments': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'otherDeductions': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalance
     */
    'outBalance': number;
}
/**
 * 
 * @export
 * @interface PositionBalanceExtendedDto
 */
export interface PositionBalanceExtendedDto {
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'departmentName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'jobName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'workTimeNormName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'paymentTypeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'calcMethod'?: string;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'paySumECB'?: number;
    /**
     * 
     * @type {Array<CalcMethodBalanceDto>}
     * @memberof PositionBalanceExtendedDto
     */
    'calcMethodBalance': Array<CalcMethodBalanceDto>;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'id': string;
    /**
     * 
     * @type {Position}
     * @memberof PositionBalanceExtendedDto
     */
    'position'?: Position;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'positionId': string;
    /**
     * 
     * @type {Date}
     * @memberof PositionBalanceExtendedDto
     */
    'payPeriod': Date;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'inBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'planDays': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'planHours': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'factDays': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'factHours': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'accruals': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'deductions': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'basic': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'adjustments': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'bonuses': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'vacations': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'sicks': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'refunds': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'otherAccruals': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'taxes': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'payments': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'otherDeductions': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'outBalance': number;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'companyId': string;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'cardNumber': string;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'sequenceNumber': number;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'personId': string | null;
    /**
     * 
     * @type {Date}
     * @memberof PositionBalanceExtendedDto
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof PositionBalanceExtendedDto
     */
    'dateTo': Date;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'middleName': string;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'taxId': string;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'departmentId': string | null;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'jobId': string | null;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'workTimeNormId': string | null;
    /**
     * 
     * @type {string}
     * @memberof PositionBalanceExtendedDto
     */
    'paymentTypeId': string | null;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'wage': number;
    /**
     * 
     * @type {number}
     * @memberof PositionBalanceExtendedDto
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface PositionHistory
 */
export interface PositionHistory {
    /**
     * 
     * @type {Position}
     * @memberof PositionHistory
     */
    'position'?: Position;
    /**
     * 
     * @type {string}
     * @memberof PositionHistory
     */
    'positionId': string;
    /**
     * 
     * @type {Date}
     * @memberof PositionHistory
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof PositionHistory
     */
    'dateTo': Date;
    /**
     * 
     * @type {Department}
     * @memberof PositionHistory
     */
    'department'?: Department;
    /**
     * 
     * @type {string}
     * @memberof PositionHistory
     */
    'departmentId': string | null;
    /**
     * 
     * @type {Job}
     * @memberof PositionHistory
     */
    'job'?: Job;
    /**
     * 
     * @type {string}
     * @memberof PositionHistory
     */
    'jobId': string | null;
    /**
     * 
     * @type {WorkTimeNorm}
     * @memberof PositionHistory
     */
    'workTimeNorm'?: WorkTimeNorm;
    /**
     * 
     * @type {string}
     * @memberof PositionHistory
     */
    'workTimeNormId': string | null;
    /**
     * 
     * @type {PaymentType}
     * @memberof PositionHistory
     */
    'paymentType'?: PaymentType;
    /**
     * 
     * @type {string}
     * @memberof PositionHistory
     */
    'paymentTypeId': string | null;
    /**
     * 
     * @type {number}
     * @memberof PositionHistory
     */
    'wage': number;
    /**
     * 
     * @type {number}
     * @memberof PositionHistory
     */
    'rate': number;
    /**
     * 
     * @type {Date}
     * @memberof PositionHistory
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof PositionHistory
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof PositionHistory
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof PositionHistory
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof PositionHistory
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof PositionHistory
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PositionHistory
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof PositionHistory
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ProcessPaymentDto
 */
export interface ProcessPaymentDto {
    /**
     * 
     * @type {number}
     * @memberof ProcessPaymentDto
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface PublicUserDataDto
 */
export interface PublicUserDataDto {
    /**
     * 
     * @type {string}
     * @memberof PublicUserDataDto
     */
    'id'?: string;
    /**
     * 
     * @type {Date}
     * @memberof PublicUserDataDto
     */
    'createdDate'?: Date;
    /**
     * 
     * @type {string}
     * @memberof PublicUserDataDto
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof PublicUserDataDto
     */
    'updatedDate'?: Date;
    /**
     * 
     * @type {string}
     * @memberof PublicUserDataDto
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof PublicUserDataDto
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof PublicUserDataDto
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PublicUserDataDto
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof PublicUserDataDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUserDataDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUserDataDto
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicUserDataDto
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicUserDataDto
     */
    'language'?: string | null;
    /**
     * 
     * @type {Role}
     * @memberof PublicUserDataDto
     */
    'role'?: Role;
    /**
     * 
     * @type {string}
     * @memberof PublicUserDataDto
     */
    'roleId'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RecordFlags = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_4: 4,
    NUMBER_8: 8
} as const;

export type RecordFlags = typeof RecordFlags[keyof typeof RecordFlags];


/**
 * 
 * @export
 * @enum {string}
 */

export const Resource = {
    Access: 'access',
    Account: 'account',
    Accounting: 'accounting',
    AppTitle: 'app-title',
    Candidate: 'candidate',
    Company: 'company',
    Dashboard: 'dashboard',
    Demo: 'demo',
    Department: 'department',
    Dismissed: 'dismissed',
    Document: 'document',
    FundType: 'fund-type',
    Job: 'job',
    Law: 'law',
    Manager: 'manager',
    MaxBaseUfc: 'max-base-ufc',
    MinWage: 'min-wage',
    Notes: 'notes',
    PayFund: 'pay-fund',
    Payment: 'payment',
    PaymentPosition: 'payment-position',
    PaymentType: 'payment-type',
    PayPeriod: 'pay-period',
    Payroll: 'payroll',
    Person: 'person',
    Position: 'position',
    PositionHistory: 'position-history',
    Profile: 'profile',
    Report: 'report',
    Role: 'role',
    RoleAccess: 'role-access',
    Task: 'task',
    TimeOff: 'time-off',
    Timesheet: 'timesheet',
    User: 'user',
    UserAccess: 'user-access',
    Vacancy: 'vacancy',
    WorkTimeNorm: 'work-time-norm'
} as const;

export type Resource = typeof Resource[keyof typeof Resource];


/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {RoleType}
     * @memberof Role
     */
    'type': RoleType;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'name': string;
    /**
     * 
     * @type {Date}
     * @memberof Role
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Role
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Role
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'id': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RoleType = {
    System: 'system',
    SystemAdmin: 'system-admin',
    CompanyAdmin: 'company-admin',
    Accountant: 'accountant',
    Employee: 'employee',
    Manager: 'manager'
} as const;

export type RoleType = typeof RoleType[keyof typeof RoleType];


/**
 * 
 * @export
 * @enum {string}
 */

export const ServerEvent = {
    CommunicationError: 'communication-error',
    PayrollStarted: 'payroll-started',
    PayrollFinished: 'payroll-finished',
    PayrollFailed: 'payroll-failed',
    TasklistStarted: 'tasklist-started',
    TasklistFinished: 'tasklist-finished',
    TasklistFailed: 'tasklist-failed'
} as const;

export type ServerEvent = typeof ServerEvent[keyof typeof ServerEvent];


/**
 * 
 * @export
 * @enum {string}
 */

export const Sex = {
    Male: 'male',
    Female: 'female'
} as const;

export type Sex = typeof Sex[keyof typeof Sex];


/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {TaskType}
     * @memberof Task
     */
    'type': TaskType;
    /**
     * 
     * @type {TaskStatus}
     * @memberof Task
     */
    'status': TaskStatus;
    /**
     * 
     * @type {Company}
     * @memberof Task
     */
    'company'?: Company;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'companyId': string;
    /**
     * 
     * @type {Date}
     * @memberof Task
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof Task
     */
    'dateTo': Date;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'sequenceNumber': number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'entityId': string | null;
    /**
     * 
     * @type {Date}
     * @memberof Task
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Task
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof Task
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'id': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TaskStatus = {
    NotAvailable: 'not-available',
    Todo: 'todo',
    InProgress: 'in-progress',
    Done: 'done',
    DoneByUser: 'done-by-user'
} as const;

export type TaskStatus = typeof TaskStatus[keyof typeof TaskStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const TaskType = {
    CreateUser: 'create-user',
    CreateCompany: 'create-company',
    FillDepartmentList: 'fill-department-list',
    FillPositionList: 'fill-position-list',
    PostWorkSheet: 'post-work-sheet',
    PostAccrualDocument: 'post-accrual-document',
    SendApplicationFss: 'send-application-fss',
    PostPaymentFss: 'post-payment-fss',
    PostAdvancePayment: 'post-advance-payment',
    PostRegularPayment: 'post-regular-payment',
    ClosePayPeriod: 'close-pay-period',
    SendIncomeTaxReport: 'send-income-tax-report',
    HappyBirthday: 'happy-birthday'
} as const;

export type TaskType = typeof TaskType[keyof typeof TaskType];


/**
 * 
 * @export
 * @interface TokensDto
 */
export interface TokensDto {
    /**
     * 
     * @type {string}
     * @memberof TokensDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof TokensDto
     */
    'refreshToken': string | null;
}
/**
 * 
 * @export
 * @interface UpdateAccessDto
 */
export interface UpdateAccessDto {
    /**
     * 
     * @type {RoleType}
     * @memberof UpdateAccessDto
     */
    'roleType'?: RoleType;
    /**
     * 
     * @type {Resource}
     * @memberof UpdateAccessDto
     */
    'resource'?: Resource;
    /**
     * 
     * @type {Action}
     * @memberof UpdateAccessDto
     */
    'action'?: Action;
}


/**
 * 
 * @export
 * @interface UpdateCompanyDto
 */
export interface UpdateCompanyDto {
    /**
     * 
     * @type {PaymentSchedule}
     * @memberof UpdateCompanyDto
     */
    'paymentSchedule'?: PaymentSchedule;
    /**
     * 
     * @type {number}
     * @memberof UpdateCompanyDto
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateCompanyDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCompanyDto
     */
    'lawId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCompanyDto
     */
    'accountingId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCompanyDto
     */
    'taxId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdateCompanyDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdateCompanyDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdateCompanyDto
     */
    'payPeriod'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdateCompanyDto
     */
    'checkDate'?: Date;
}


/**
 * 
 * @export
 * @interface UpdateDepartmentDto
 */
export interface UpdateDepartmentDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateDepartmentDto
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateDepartmentDto
     */
    'companyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDepartmentDto
     */
    'name'?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdateDepartmentDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdateDepartmentDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {string}
     * @memberof UpdateDepartmentDto
     */
    'parentDepartmentId'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateJobDto
 */
export interface UpdateJobDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateJobDto
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateJobDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMinWageDto
 */
export interface UpdateMinWageDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateMinWageDto
     */
    'version': number;
    /**
     * 
     * @type {Date}
     * @memberof UpdateMinWageDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdateMinWageDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {number}
     * @memberof UpdateMinWageDto
     */
    'paySum'?: number;
}
/**
 * 
 * @export
 * @interface UpdatePayFundDto
 */
export interface UpdatePayFundDto {
    /**
     * 
     * @type {PayFundCategory}
     * @memberof UpdatePayFundDto
     */
    'payFundCategory'?: PayFundCategory;
    /**
     * 
     * @type {string}
     * @memberof UpdatePayFundDto
     */
    'positionId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePayFundDto
     */
    'payPeriod'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePayFundDto
     */
    'accPeriod'?: Date;
    /**
     * 
     * @type {string}
     * @memberof UpdatePayFundDto
     */
    'payFundTypeId'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayFundDto
     */
    'incomeSum'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayFundDto
     */
    'baseSum'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayFundDto
     */
    'rate'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayFundDto
     */
    'paySum'?: number;
}


/**
 * 
 * @export
 * @interface UpdatePayFundTypeDto
 */
export interface UpdatePayFundTypeDto {
    /**
     * 
     * @type {PayFundGroup}
     * @memberof UpdatePayFundTypeDto
     */
    'group'?: PayFundGroup;
    /**
     * 
     * @type {PayFundCalcMethod}
     * @memberof UpdatePayFundTypeDto
     */
    'calcMethod'?: PayFundCalcMethod;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayFundTypeDto
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePayFundTypeDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayFundTypeDto
     */
    'sequence'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePayFundTypeDto
     */
    'description'?: string;
}


/**
 * 
 * @export
 * @interface UpdatePayPeriodDto
 */
export interface UpdatePayPeriodDto {
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'version': number;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePayPeriodDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePayPeriodDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {string}
     * @memberof UpdatePayPeriodDto
     */
    'state'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'inBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'inCompanyDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'inEmployeeDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'accruals'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'deductions'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'basic'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'adjustments'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'bonuses'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'vacations'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'sicks'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'refunds'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'otherAccruals'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'taxes'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'payments'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'otherDeductions'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'outBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'outCompanyDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'outEmployeeDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayPeriodDto
     */
    'funds'?: number;
    /**
     * 
     * @type {Array<PayPeriodSummary>}
     * @memberof UpdatePayPeriodDto
     */
    'calcMethods'?: Array<PayPeriodSummary>;
}
/**
 * 
 * @export
 * @interface UpdatePaymentDto
 */
export interface UpdatePaymentDto {
    /**
     * 
     * @type {PaymentStatus}
     * @memberof UpdatePaymentDto
     */
    'status'?: PaymentStatus;
    /**
     * 
     * @type {RecordFlags}
     * @memberof UpdatePaymentDto
     */
    'recordFlags'?: RecordFlags;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentDto
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentDto
     */
    'companyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentDto
     */
    'paymentTypeId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePaymentDto
     */
    'payPeriod'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePaymentDto
     */
    'accPeriod'?: Date;
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentDto
     */
    'docNumber'?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePaymentDto
     */
    'docDate'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePaymentDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePaymentDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentDto
     */
    'baseSum'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentDto
     */
    'deductions'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentDto
     */
    'paySum'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentDto
     */
    'funds'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentDto
     */
    'description'?: string;
}


/**
 * 
 * @export
 * @interface UpdatePaymentPositionDto
 */
export interface UpdatePaymentPositionDto {
    /**
     * 
     * @type {RecordFlags}
     * @memberof UpdatePaymentPositionDto
     */
    'recordFlags'?: RecordFlags;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentPositionDto
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentPositionDto
     */
    'paymentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentPositionDto
     */
    'positionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentPositionDto
     */
    'baseSum'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentPositionDto
     */
    'deductions'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentPositionDto
     */
    'paySum'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentPositionDto
     */
    'funds'?: number;
}


/**
 * 
 * @export
 * @interface UpdatePaymentTypeDto
 */
export interface UpdatePaymentTypeDto {
    /**
     * 
     * @type {PaymentPart}
     * @memberof UpdatePaymentTypeDto
     */
    'paymentPart'?: PaymentPart;
    /**
     * 
     * @type {PaymentGroup}
     * @memberof UpdatePaymentTypeDto
     */
    'paymentGroup'?: PaymentGroup;
    /**
     * 
     * @type {CalcMethod}
     * @memberof UpdatePaymentTypeDto
     */
    'calcMethod'?: CalcMethod;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentTypeDto
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentTypeDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentTypeDto
     */
    'description'?: string;
}


/**
 * 
 * @export
 * @interface UpdatePayrollDto
 */
export interface UpdatePayrollDto {
    /**
     * 
     * @type {Resource}
     * @memberof UpdatePayrollDto
     */
    'sourceType'?: Resource;
    /**
     * 
     * @type {RecordFlags}
     * @memberof UpdatePayrollDto
     */
    'recordFlags'?: RecordFlags;
    /**
     * 
     * @type {FixedFlags}
     * @memberof UpdatePayrollDto
     */
    'fixedFlags'?: FixedFlags;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayrollDto
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePayrollDto
     */
    'positionId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePayrollDto
     */
    'payPeriod'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePayrollDto
     */
    'accPeriod'?: Date;
    /**
     * 
     * @type {string}
     * @memberof UpdatePayrollDto
     */
    'paymentTypeId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePayrollDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePayrollDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {string}
     * @memberof UpdatePayrollDto
     */
    'sourceId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePayrollDto
     */
    'dateBegin'?: Date | null;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePayrollDto
     */
    'dateEnd'?: Date | null;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayrollDto
     */
    'planDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayrollDto
     */
    'planHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayrollDto
     */
    'planSum'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayrollDto
     */
    'rate'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayrollDto
     */
    'factDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayrollDto
     */
    'factHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayrollDto
     */
    'factSum'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayrollDto
     */
    'mask1'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePayrollDto
     */
    'mask2'?: number;
    /**
     * 
     * @type {object}
     * @memberof UpdatePayrollDto
     */
    'planHoursByDay'?: object | null;
    /**
     * 
     * @type {object}
     * @memberof UpdatePayrollDto
     */
    'factHoursByDay'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdatePayrollDto
     */
    'parentId'?: string | null;
}


/**
 * 
 * @export
 * @interface UpdatePersonDto
 */
export interface UpdatePersonDto {
    /**
     * 
     * @type {Sex}
     * @memberof UpdatePersonDto
     */
    'sex'?: Sex;
    /**
     * 
     * @type {number}
     * @memberof UpdatePersonDto
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonDto
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonDto
     */
    'fullName'?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePersonDto
     */
    'birthday'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonDto
     */
    'taxId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonDto
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonDto
     */
    'photo'?: string;
}


/**
 * 
 * @export
 * @interface UpdatePositionDto
 */
export interface UpdatePositionDto {
    /**
     * 
     * @type {number}
     * @memberof UpdatePositionDto
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePositionDto
     */
    'companyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePositionDto
     */
    'cardNumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdatePositionDto
     */
    'sequenceNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePositionDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePositionDto
     */
    'personId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePositionDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePositionDto
     */
    'dateTo'?: Date;
}
/**
 * 
 * @export
 * @interface UpdatePositionHistoryDto
 */
export interface UpdatePositionHistoryDto {
    /**
     * 
     * @type {number}
     * @memberof UpdatePositionHistoryDto
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePositionHistoryDto
     */
    'positionId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePositionHistoryDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdatePositionHistoryDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {string}
     * @memberof UpdatePositionHistoryDto
     */
    'departmentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdatePositionHistoryDto
     */
    'jobId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdatePositionHistoryDto
     */
    'workTimeNormId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdatePositionHistoryDto
     */
    'paymentTypeId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdatePositionHistoryDto
     */
    'wage'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePositionHistoryDto
     */
    'rate'?: number;
}
/**
 * 
 * @export
 * @interface UpdateRoleDto
 */
export interface UpdateRoleDto {
    /**
     * 
     * @type {RoleType}
     * @memberof UpdateRoleDto
     */
    'type'?: RoleType;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleDto
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @interface UpdateTaskDto
 */
export interface UpdateTaskDto {
    /**
     * 
     * @type {TaskType}
     * @memberof UpdateTaskDto
     */
    'type'?: TaskType;
    /**
     * 
     * @type {TaskStatus}
     * @memberof UpdateTaskDto
     */
    'status'?: TaskStatus;
    /**
     * 
     * @type {number}
     * @memberof UpdateTaskDto
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'companyId'?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdateTaskDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdateTaskDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {number}
     * @memberof UpdateTaskDto
     */
    'sequenceNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'entityId'?: string | null;
}


/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {Date}
     * @memberof UpdateUserDto
     */
    'createdDate'?: Date;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof UpdateUserDto
     */
    'updatedDate'?: Date;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof UpdateUserDto
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateUserDto
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'refreshToken'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'language'?: string | null;
    /**
     * 
     * @type {Role}
     * @memberof UpdateUserDto
     */
    'role'?: Role;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'roleId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateWorkTimeNormDto
 */
export interface UpdateWorkTimeNormDto {
    /**
     * 
     * @type {WorkTimeNormType}
     * @memberof UpdateWorkTimeNormDto
     */
    'type'?: WorkTimeNormType;
    /**
     * 
     * @type {number}
     * @memberof UpdateWorkTimeNormDto
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTimeNormDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTimeNormDto
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTimeNormDto
     */
    'description'?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdateWorkTimeNormDto
     */
    'dateFrom'?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdateWorkTimeNormDto
     */
    'dateTo'?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWorkTimeNormDto
     */
    'applyHolidays'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWorkTimeNormDto
     */
    'applyShortenedDays'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWorkTimeNormDto
     */
    'applyMovedDays'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWorkTimeNormDto
     */
    'applyPhases'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWorkTimeNormDto
     */
    'applyRate'?: boolean;
}


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'refreshToken': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'language': string | null;
    /**
     * 
     * @type {Role}
     * @memberof User
     */
    'role'?: Role;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'roleId': string;
    /**
     * 
     * @type {Date}
     * @memberof User
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof User
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof User
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface UserCompany
 */
export interface UserCompany {
    /**
     * 
     * @type {User}
     * @memberof UserCompany
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof UserCompany
     */
    'userId': string;
    /**
     * 
     * @type {Company}
     * @memberof UserCompany
     */
    'company'?: Company;
    /**
     * 
     * @type {string}
     * @memberof UserCompany
     */
    'companyId': string;
    /**
     * 
     * @type {Role}
     * @memberof UserCompany
     */
    'role'?: Role;
    /**
     * 
     * @type {string}
     * @memberof UserCompany
     */
    'roleId': string;
    /**
     * 
     * @type {Date}
     * @memberof UserCompany
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof UserCompany
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof UserCompany
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof UserCompany
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof UserCompany
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof UserCompany
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserCompany
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof UserCompany
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface WithdrawPaymentDto
 */
export interface WithdrawPaymentDto {
    /**
     * 
     * @type {number}
     * @memberof WithdrawPaymentDto
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface WorkTimeNorm
 */
export interface WorkTimeNorm {
    /**
     * 
     * @type {WorkTimeNormType}
     * @memberof WorkTimeNorm
     */
    'type': WorkTimeNormType;
    /**
     * 
     * @type {string}
     * @memberof WorkTimeNorm
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof WorkTimeNorm
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkTimeNorm
     */
    'description': string;
    /**
     * 
     * @type {Date}
     * @memberof WorkTimeNorm
     */
    'dateFrom': Date;
    /**
     * 
     * @type {Date}
     * @memberof WorkTimeNorm
     */
    'dateTo': Date;
    /**
     * 
     * @type {boolean}
     * @memberof WorkTimeNorm
     */
    'applyHolidays': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkTimeNorm
     */
    'applyShortenedDays': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkTimeNorm
     */
    'applyMovedDays': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkTimeNorm
     */
    'applyPhases': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkTimeNorm
     */
    'applyRate': boolean;
    /**
     * 
     * @type {Array<WorkTimeNormDay>}
     * @memberof WorkTimeNorm
     */
    'days'?: Array<WorkTimeNormDay>;
    /**
     * 
     * @type {Date}
     * @memberof WorkTimeNorm
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof WorkTimeNorm
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof WorkTimeNorm
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof WorkTimeNorm
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof WorkTimeNorm
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof WorkTimeNorm
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorkTimeNorm
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof WorkTimeNorm
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface WorkTimeNormDay
 */
export interface WorkTimeNormDay {
    /**
     * 
     * @type {WorkTimeNorm}
     * @memberof WorkTimeNormDay
     */
    'workTimeNorm'?: WorkTimeNorm;
    /**
     * 
     * @type {string}
     * @memberof WorkTimeNormDay
     */
    'workTimeNormId': string;
    /**
     * 
     * @type {number}
     * @memberof WorkTimeNormDay
     */
    'day': number;
    /**
     * 
     * @type {number}
     * @memberof WorkTimeNormDay
     */
    'hours': number;
    /**
     * 
     * @type {Date}
     * @memberof WorkTimeNormDay
     */
    'createdDate': Date;
    /**
     * 
     * @type {string}
     * @memberof WorkTimeNormDay
     */
    'createdUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof WorkTimeNormDay
     */
    'updatedDate': Date;
    /**
     * 
     * @type {string}
     * @memberof WorkTimeNormDay
     */
    'updatedUserId'?: string | null;
    /**
     * 
     * @type {Date}
     * @memberof WorkTimeNormDay
     */
    'deletedDate'?: Date | null;
    /**
     * 
     * @type {string}
     * @memberof WorkTimeNormDay
     */
    'deletedUserId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorkTimeNormDay
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof WorkTimeNormDay
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WorkTimeNormType = {
    Day: 'day',
    Month: 'month',
    Quarter: 'quarter',
    HalfYear: 'half-year',
    Year: 'year'
} as const;

export type WorkTimeNormType = typeof WorkTimeNormType[keyof typeof WorkTimeNormType];



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check access
         * @param {AvailableAccessDto} availableAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessAvailable: async (availableAccessDto: AvailableAccessDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableAccessDto' is not null or undefined
            assertParamExists('accessAvailable', 'availableAccessDto', availableAccessDto)
            const localVarPath = `/api/access/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(availableAccessDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check access for user
         * @param {AvailableAccessUserDto} availableAccessUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessAvailableForUser: async (availableAccessUserDto: AvailableAccessUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableAccessUserDto' is not null or undefined
            assertParamExists('accessAvailableForUser', 'availableAccessUserDto', availableAccessUserDto)
            const localVarPath = `/api/access/available-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(availableAccessUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check access for user in a company
         * @param {AvailableAccessUserCompanyDto} availableAccessUserCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessAvailableForUserCompany: async (availableAccessUserCompanyDto: AvailableAccessUserCompanyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableAccessUserCompanyDto' is not null or undefined
            assertParamExists('accessAvailableForUserCompany', 'availableAccessUserCompanyDto', availableAccessUserCompanyDto)
            const localVarPath = `/api/access/available-user-company`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(availableAccessUserCompanyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an access record
         * @param {CreateAccessDto} createAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessCreate: async (createAccessDto: CreateAccessDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccessDto' is not null or undefined
            assertParamExists('accessCreate', 'createAccessDto', createAccessDto)
            const localVarPath = `/api/access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccessDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roleType 
         * @param {string} resource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessFindAll: async (roleType: string, resource: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleType' is not null or undefined
            assertParamExists('accessFindAll', 'roleType', roleType)
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('accessFindAll', 'resource', resource)
            const localVarPath = `/api/access`
                .replace(`{${"roleType"}}`, encodeURIComponent(String(roleType)))
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessFindOne', 'id', id)
            const localVarPath = `/api/access/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete an access record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessRemove', 'id', id)
            const localVarPath = `/api/access/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an access record
         * @param {string} id 
         * @param {UpdateAccessDto} updateAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessUpdate: async (id: string, updateAccessDto: UpdateAccessDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessUpdate', 'id', id)
            // verify required parameter 'updateAccessDto' is not null or undefined
            assertParamExists('accessUpdate', 'updateAccessDto', updateAccessDto)
            const localVarPath = `/api/access/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccessDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountingFindOne', 'id', id)
            const localVarPath = `/api/accounting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lng 
         * @param {string} ns 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAddLocales: async (lng: string, ns: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lng' is not null or undefined
            assertParamExists('appAddLocales', 'lng', lng)
            // verify required parameter 'ns' is not null or undefined
            assertParamExists('appAddLocales', 'ns', ns)
            const localVarPath = `/api/locales/add/{lng}/{ns}`
                .replace(`{${"lng"}}`, encodeURIComponent(String(lng)))
                .replace(`{${"ns"}}`, encodeURIComponent(String(ns)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lang 
         * @param {string} ns 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGetLocales: async (lang: string, ns: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lang' is not null or undefined
            assertParamExists('appGetLocales', 'lang', lang)
            // verify required parameter 'ns' is not null or undefined
            assertParamExists('appGetLocales', 'ns', ns)
            const localVarPath = `/api/locales/{lang}/{ns}.json`
                .replace(`{${"lang"}}`, encodeURIComponent(String(lang)))
                .replace(`{${"ns"}}`, encodeURIComponent(String(ns)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGetTitle: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/title`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get response for a health checker
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPing: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDemo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/demo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthDto} authDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin: async (authDto: AuthDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authDto' is not null or undefined
            assertParamExists('authLogin', 'authDto', authDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegister: async (createUserDto: CreateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('authRegister', 'createUserDto', createUserDto)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create company
         * @param {CreateCompanyDto} createCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesCreate: async (createCompanyDto: CreateCompanyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCompanyDto' is not null or undefined
            assertParamExists('companiesCreate', 'createCompanyDto', createCompanyDto)
            const localVarPath = `/api/companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCompanyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesFindLast: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/companies/last`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('companiesFindOne', 'id', id)
            const localVarPath = `/api/companies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a company
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('companiesRemove', 'id', id)
            const localVarPath = `/api/companies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Calculate salary for a company
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesSalaryCalculate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('companiesSalaryCalculate', 'id', id)
            const localVarPath = `/api/companies/{id}/calculate-payroll`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a company
         * @param {string} id 
         * @param {UpdateCompanyDto} updateCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesUpdate: async (id: string, updateCompanyDto: UpdateCompanyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('companiesUpdate', 'id', id)
            // verify required parameter 'updateCompanyDto' is not null or undefined
            assertParamExists('companiesUpdate', 'updateCompanyDto', updateCompanyDto)
            const localVarPath = `/api/companies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCompanyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create department
         * @param {CreateDepartmentDto} createDepartmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsCreate: async (createDepartmentDto: CreateDepartmentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDepartmentDto' is not null or undefined
            assertParamExists('departmentsCreate', 'createDepartmentDto', createDepartmentDto)
            const localVarPath = `/api/departments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDepartmentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindAllDepartmentDto} findAllDepartmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsFindAll: async (findAllDepartmentDto: FindAllDepartmentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findAllDepartmentDto' is not null or undefined
            assertParamExists('departmentsFindAll', 'findAllDepartmentDto', findAllDepartmentDto)
            const localVarPath = `/api/departments/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findAllDepartmentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOneDepartmentDto} findOneDepartmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsFindOne: async (id: string, findOneDepartmentDto: FindOneDepartmentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('departmentsFindOne', 'id', id)
            // verify required parameter 'findOneDepartmentDto' is not null or undefined
            assertParamExists('departmentsFindOne', 'findOneDepartmentDto', findOneDepartmentDto)
            const localVarPath = `/api/departments/find/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findOneDepartmentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a department
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('departmentsRemove', 'id', id)
            const localVarPath = `/api/departments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a department
         * @param {string} id 
         * @param {UpdateDepartmentDto} updateDepartmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsUpdate: async (id: string, updateDepartmentDto: UpdateDepartmentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('departmentsUpdate', 'id', id)
            // verify required parameter 'updateDepartmentDto' is not null or undefined
            assertParamExists('departmentsUpdate', 'updateDepartmentDto', updateDepartmentDto)
            const localVarPath = `/api/departments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDepartmentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create job
         * @param {CreateJobDto} createJobDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsCreate: async (createJobDto: CreateJobDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createJobDto' is not null or undefined
            assertParamExists('jobsCreate', 'createJobDto', createJobDto)
            const localVarPath = `/api/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createJobDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsFindOne', 'id', id)
            const localVarPath = `/api/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsRemove', 'id', id)
            const localVarPath = `/api/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a job
         * @param {string} id 
         * @param {UpdateJobDto} updateJobDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsUpdate: async (id: string, updateJobDto: UpdateJobDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsUpdate', 'id', id)
            // verify required parameter 'updateJobDto' is not null or undefined
            assertParamExists('jobsUpdate', 'updateJobDto', updateJobDto)
            const localVarPath = `/api/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateJobDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lawsFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/laws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lawsFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lawsFindOne', 'id', id)
            const localVarPath = `/api/laws/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minWageFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/min-wage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minWageFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('minWageFindOne', 'id', id)
            const localVarPath = `/api/min-wage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a Min Wage record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minWageRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('minWageRemove', 'id', id)
            const localVarPath = `/api/min-wage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Min Wage record
         * @param {string} id 
         * @param {UpdateMinWageDto} updateMinWageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minWageUpdate: async (id: string, updateMinWageDto: UpdateMinWageDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('minWageUpdate', 'id', id)
            // verify required parameter 'updateMinWageDto' is not null or undefined
            assertParamExists('minWageUpdate', 'updateMinWageDto', updateMinWageDto)
            const localVarPath = `/api/min-wage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMinWageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Pay Fund Type record
         * @param {CreatePayFundTypeDto} createPayFundTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundTypesCreate: async (createPayFundTypeDto: CreatePayFundTypeDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPayFundTypeDto' is not null or undefined
            assertParamExists('payFundTypesCreate', 'createPayFundTypeDto', createPayFundTypeDto)
            const localVarPath = `/api/pay-fund-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPayFundTypeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundTypesFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pay-fund-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundTypesFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payFundTypesFindOne', 'id', id)
            const localVarPath = `/api/pay-fund-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a Pay Fund Type record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundTypesRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payFundTypesRemove', 'id', id)
            const localVarPath = `/api/pay-fund-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Pay Fund Type record
         * @param {string} id 
         * @param {UpdatePayFundTypeDto} updatePayFundTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundTypesUpdate: async (id: string, updatePayFundTypeDto: UpdatePayFundTypeDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payFundTypesUpdate', 'id', id)
            // verify required parameter 'updatePayFundTypeDto' is not null or undefined
            assertParamExists('payFundTypesUpdate', 'updatePayFundTypeDto', updatePayFundTypeDto)
            const localVarPath = `/api/pay-fund-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePayFundTypeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Pay Fund record
         * @param {CreatePayFundDto} createPayFundDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundsCreate: async (createPayFundDto: CreatePayFundDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPayFundDto' is not null or undefined
            assertParamExists('payFundsCreate', 'createPayFundDto', createPayFundDto)
            const localVarPath = `/api/fund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPayFundDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindPayFundDto} findPayFundDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundsFindAll: async (findPayFundDto: FindPayFundDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findPayFundDto' is not null or undefined
            assertParamExists('payFundsFindAll', 'findPayFundDto', findPayFundDto)
            const localVarPath = `/api/fund/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findPayFundDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} relations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundsFindOne: async (id: string, relations: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payFundsFindOne', 'id', id)
            // verify required parameter 'relations' is not null or undefined
            assertParamExists('payFundsFindOne', 'relations', relations)
            const localVarPath = `/api/fund/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (relations !== undefined) {
                localVarQueryParameter['relations'] = relations;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Pay Fund record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundsRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payFundsRemove', 'id', id)
            const localVarPath = `/api/fund/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdatePayFundDto} updatePayFundDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundsUpdate: async (id: string, updatePayFundDto: UpdatePayFundDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payFundsUpdate', 'id', id)
            // verify required parameter 'updatePayFundDto' is not null or undefined
            assertParamExists('payFundsUpdate', 'updatePayFundDto', updatePayFundDto)
            const localVarPath = `/api/fund/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePayFundDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Close Pay Period
         * @param {string} id 
         * @param {ClosePayPeriodDto} closePayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsClose: async (id: string, closePayPeriodDto: ClosePayPeriodDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payPeriodsClose', 'id', id)
            // verify required parameter 'closePayPeriodDto' is not null or undefined
            assertParamExists('payPeriodsClose', 'closePayPeriodDto', closePayPeriodDto)
            const localVarPath = `/api/pay-periods/close/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(closePayPeriodDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Pay Period record
         * @param {CreatePayPeriodDto} createPayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsCreate: async (createPayPeriodDto: CreatePayPeriodDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPayPeriodDto' is not null or undefined
            assertParamExists('payPeriodsCreate', 'createPayPeriodDto', createPayPeriodDto)
            const localVarPath = `/api/pay-periods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPayPeriodDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindAllPayPeriodDto} findAllPayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsFindAll: async (findAllPayPeriodDto: FindAllPayPeriodDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findAllPayPeriodDto' is not null or undefined
            assertParamExists('payPeriodsFindAll', 'findAllPayPeriodDto', findAllPayPeriodDto)
            const localVarPath = `/api/pay-periods/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findAllPayPeriodDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindCurrentPayPeriodDto} findCurrentPayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsFindCurrent: async (findCurrentPayPeriodDto: FindCurrentPayPeriodDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findCurrentPayPeriodDto' is not null or undefined
            assertParamExists('payPeriodsFindCurrent', 'findCurrentPayPeriodDto', findCurrentPayPeriodDto)
            const localVarPath = `/api/pay-periods/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findCurrentPayPeriodDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePayPeriodDto} findOnePayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsFindOne: async (id: string, findOnePayPeriodDto: FindOnePayPeriodDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payPeriodsFindOne', 'id', id)
            // verify required parameter 'findOnePayPeriodDto' is not null or undefined
            assertParamExists('payPeriodsFindOne', 'findOnePayPeriodDto', findOnePayPeriodDto)
            const localVarPath = `/api/pay-periods/find/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findOnePayPeriodDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Open Pay Period
         * @param {string} id 
         * @param {OpenPayPeriodDto} openPayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsOpen: async (id: string, openPayPeriodDto: OpenPayPeriodDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payPeriodsOpen', 'id', id)
            // verify required parameter 'openPayPeriodDto' is not null or undefined
            assertParamExists('payPeriodsOpen', 'openPayPeriodDto', openPayPeriodDto)
            const localVarPath = `/api/pay-periods/open/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openPayPeriodDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a Pay Period record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payPeriodsRemove', 'id', id)
            const localVarPath = `/api/pay-periods/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Pay Period record
         * @param {string} id 
         * @param {UpdatePayPeriodDto} updatePayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsUpdate: async (id: string, updatePayPeriodDto: UpdatePayPeriodDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payPeriodsUpdate', 'id', id)
            // verify required parameter 'updatePayPeriodDto' is not null or undefined
            assertParamExists('payPeriodsUpdate', 'updatePayPeriodDto', updatePayPeriodDto)
            const localVarPath = `/api/pay-periods/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePayPeriodDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Payment Position record
         * @param {CreatePaymentPositionDto} createPaymentPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPositionsCreate: async (createPaymentPositionDto: CreatePaymentPositionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPaymentPositionDto' is not null or undefined
            assertParamExists('paymentPositionsCreate', 'createPaymentPositionDto', createPaymentPositionDto)
            const localVarPath = `/api/payment-positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentPositionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindAllPaymentPositionDto} findAllPaymentPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPositionsFindAll: async (findAllPaymentPositionDto: FindAllPaymentPositionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findAllPaymentPositionDto' is not null or undefined
            assertParamExists('paymentPositionsFindAll', 'findAllPaymentPositionDto', findAllPaymentPositionDto)
            const localVarPath = `/api/payment-positions/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findAllPaymentPositionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePaymentPositionDto} findOnePaymentPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPositionsFindOne: async (id: string, findOnePaymentPositionDto: FindOnePaymentPositionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentPositionsFindOne', 'id', id)
            // verify required parameter 'findOnePaymentPositionDto' is not null or undefined
            assertParamExists('paymentPositionsFindOne', 'findOnePaymentPositionDto', findOnePaymentPositionDto)
            const localVarPath = `/api/payment-positions/find/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findOnePaymentPositionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a Payment Position record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPositionsRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentPositionsRemove', 'id', id)
            const localVarPath = `/api/payment-positions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Payment Position record
         * @param {string} id 
         * @param {UpdatePaymentPositionDto} updatePaymentPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPositionsUpdate: async (id: string, updatePaymentPositionDto: UpdatePaymentPositionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentPositionsUpdate', 'id', id)
            // verify required parameter 'updatePaymentPositionDto' is not null or undefined
            assertParamExists('paymentPositionsUpdate', 'updatePaymentPositionDto', updatePaymentPositionDto)
            const localVarPath = `/api/payment-positions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePaymentPositionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Payment Type record
         * @param {CreatePaymentTypeDto} createPaymentTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypesCreate: async (createPaymentTypeDto: CreatePaymentTypeDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPaymentTypeDto' is not null or undefined
            assertParamExists('paymentTypesCreate', 'createPaymentTypeDto', createPaymentTypeDto)
            const localVarPath = `/api/payment-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentTypeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindAllPaymentTypeDto} findAllPaymentTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypesFindAll: async (findAllPaymentTypeDto: FindAllPaymentTypeDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findAllPaymentTypeDto' is not null or undefined
            assertParamExists('paymentTypesFindAll', 'findAllPaymentTypeDto', findAllPaymentTypeDto)
            const localVarPath = `/api/payment-types/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findAllPaymentTypeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypesFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentTypesFindOne', 'id', id)
            const localVarPath = `/api/payment-types/id`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a Payment Type record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypesRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentTypesRemove', 'id', id)
            const localVarPath = `/api/payment-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Payment Type record
         * @param {string} id 
         * @param {UpdatePaymentTypeDto} updatePaymentTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypesUpdate: async (id: string, updatePaymentTypeDto: UpdatePaymentTypeDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentTypesUpdate', 'id', id)
            // verify required parameter 'updatePaymentTypeDto' is not null or undefined
            assertParamExists('paymentTypesUpdate', 'updatePaymentTypeDto', updatePaymentTypeDto)
            const localVarPath = `/api/payment-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePaymentTypeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create payment
         * @param {CreatePaymentDto} createPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCreate: async (createPaymentDto: CreatePaymentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPaymentDto' is not null or undefined
            assertParamExists('paymentsCreate', 'createPaymentDto', createPaymentDto)
            const localVarPath = `/api/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindAllPaymentDto} findAllPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsFindAll: async (findAllPaymentDto: FindAllPaymentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findAllPaymentDto' is not null or undefined
            assertParamExists('paymentsFindAll', 'findAllPaymentDto', findAllPaymentDto)
            const localVarPath = `/api/payments/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findAllPaymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePaymentDto} findOnePaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsFindOne: async (id: string, findOnePaymentDto: FindOnePaymentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentsFindOne', 'id', id)
            // verify required parameter 'findOnePaymentDto' is not null or undefined
            assertParamExists('paymentsFindOne', 'findOnePaymentDto', findOnePaymentDto)
            const localVarPath = `/api/payments/find/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findOnePaymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Process payment
         * @param {string} id 
         * @param {ProcessPaymentDto} processPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsProcess: async (id: string, processPaymentDto: ProcessPaymentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentsProcess', 'id', id)
            // verify required parameter 'processPaymentDto' is not null or undefined
            assertParamExists('paymentsProcess', 'processPaymentDto', processPaymentDto)
            const localVarPath = `/api/payments/process/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processPaymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a payment record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentsRemove', 'id', id)
            const localVarPath = `/api/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore the deleted payment record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsRestore: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentsRestore', 'id', id)
            const localVarPath = `/api/payments/restore/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update payment
         * @param {string} id 
         * @param {UpdatePaymentDto} updatePaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsUpdate: async (id: string, updatePaymentDto: UpdatePaymentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentsUpdate', 'id', id)
            // verify required parameter 'updatePaymentDto' is not null or undefined
            assertParamExists('paymentsUpdate', 'updatePaymentDto', updatePaymentDto)
            const localVarPath = `/api/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePaymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Withdraw payment
         * @param {string} id 
         * @param {WithdrawPaymentDto} withdrawPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsWithdraw: async (id: string, withdrawPaymentDto: WithdrawPaymentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentsWithdraw', 'id', id)
            // verify required parameter 'withdrawPaymentDto' is not null or undefined
            assertParamExists('paymentsWithdraw', 'withdrawPaymentDto', withdrawPaymentDto)
            const localVarPath = `/api/payments/withdraw/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawPaymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create payroll
         * @param {CreatePayrollDto} createPayrollDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsCreate: async (createPayrollDto: CreatePayrollDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPayrollDto' is not null or undefined
            assertParamExists('payrollsCreate', 'createPayrollDto', createPayrollDto)
            const localVarPath = `/api/payroll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPayrollDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindPayrollDto} findPayrollDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsFindAll: async (findPayrollDto: FindPayrollDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findPayrollDto' is not null or undefined
            assertParamExists('payrollsFindAll', 'findPayrollDto', findPayrollDto)
            const localVarPath = `/api/payroll/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findPayrollDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} relations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsFindOne: async (id: string, relations: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payrollsFindOne', 'id', id)
            // verify required parameter 'relations' is not null or undefined
            assertParamExists('payrollsFindOne', 'relations', relations)
            const localVarPath = `/api/payroll/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (relations !== undefined) {
                localVarQueryParameter['relations'] = relations;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete payroll
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payrollsRemove', 'id', id)
            const localVarPath = `/api/payroll/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update payroll
         * @param {string} id 
         * @param {UpdatePayrollDto} updatePayrollDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsUpdate: async (id: string, updatePayrollDto: UpdatePayrollDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payrollsUpdate', 'id', id)
            // verify required parameter 'updatePayrollDto' is not null or undefined
            assertParamExists('payrollsUpdate', 'updatePayrollDto', updatePayrollDto)
            const localVarPath = `/api/payroll/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePayrollDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Person record
         * @param {CreatePersonDto} createPersonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personsCreate: async (createPersonDto: CreatePersonDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonDto' is not null or undefined
            assertParamExists('personsCreate', 'createPersonDto', createPersonDto)
            const localVarPath = `/api/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personsFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personsFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('personsFindOne', 'id', id)
            const localVarPath = `/api/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a Person record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personsRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('personsRemove', 'id', id)
            const localVarPath = `/api/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Person record
         * @param {string} id 
         * @param {UpdatePersonDto} updatePersonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personsUpdate: async (id: string, updatePersonDto: UpdatePersonDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('personsUpdate', 'id', id)
            // verify required parameter 'updatePersonDto' is not null or undefined
            assertParamExists('personsUpdate', 'updatePersonDto', updatePersonDto)
            const localVarPath = `/api/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePersonDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Position History record
         * @param {CreatePositionHistoryDto} createPositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionHistoryCreate: async (createPositionHistoryDto: CreatePositionHistoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPositionHistoryDto' is not null or undefined
            assertParamExists('positionHistoryCreate', 'createPositionHistoryDto', createPositionHistoryDto)
            const localVarPath = `/api/position-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPositionHistoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindAllPositionHistoryDto} findAllPositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionHistoryFindAll: async (findAllPositionHistoryDto: FindAllPositionHistoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findAllPositionHistoryDto' is not null or undefined
            assertParamExists('positionHistoryFindAll', 'findAllPositionHistoryDto', findAllPositionHistoryDto)
            const localVarPath = `/api/position-history/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findAllPositionHistoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindAllPositionHistoryDto} findAllPositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionHistoryFindLast: async (findAllPositionHistoryDto: FindAllPositionHistoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findAllPositionHistoryDto' is not null or undefined
            assertParamExists('positionHistoryFindLast', 'findAllPositionHistoryDto', findAllPositionHistoryDto)
            const localVarPath = `/api/position-history/find/last`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findAllPositionHistoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePositionHistoryDto} findOnePositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionHistoryFindOne: async (id: string, findOnePositionHistoryDto: FindOnePositionHistoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('positionHistoryFindOne', 'id', id)
            // verify required parameter 'findOnePositionHistoryDto' is not null or undefined
            assertParamExists('positionHistoryFindOne', 'findOnePositionHistoryDto', findOnePositionHistoryDto)
            const localVarPath = `/api/position-history/find/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findOnePositionHistoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a Position History record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionHistoryRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('positionHistoryRemove', 'id', id)
            const localVarPath = `/api/position-history/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Position History record
         * @param {string} id 
         * @param {UpdatePositionHistoryDto} updatePositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionHistoryUpdate: async (id: string, updatePositionHistoryDto: UpdatePositionHistoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('positionHistoryUpdate', 'id', id)
            // verify required parameter 'updatePositionHistoryDto' is not null or undefined
            assertParamExists('positionHistoryUpdate', 'updatePositionHistoryDto', updatePositionHistoryDto)
            const localVarPath = `/api/position-history/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePositionHistoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Position record
         * @param {CreatePositionDto} createPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsCreate: async (createPositionDto: CreatePositionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPositionDto' is not null or undefined
            assertParamExists('positionsCreate', 'createPositionDto', createPositionDto)
            const localVarPath = `/api/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPositionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindAllPositionDto} findAllPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsFindAll: async (findAllPositionDto: FindAllPositionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findAllPositionDto' is not null or undefined
            assertParamExists('positionsFindAll', 'findAllPositionDto', findAllPositionDto)
            const localVarPath = `/api/positions/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findAllPositionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindAllPositionBalanceDto} findAllPositionBalanceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsFindBalance: async (findAllPositionBalanceDto: FindAllPositionBalanceDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findAllPositionBalanceDto' is not null or undefined
            assertParamExists('positionsFindBalance', 'findAllPositionBalanceDto', findAllPositionBalanceDto)
            const localVarPath = `/api/positions/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findAllPositionBalanceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindPositionByPersonDto} findPositionByPersonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsFindFirstByPersonId: async (findPositionByPersonDto: FindPositionByPersonDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findPositionByPersonDto' is not null or undefined
            assertParamExists('positionsFindFirstByPersonId', 'findPositionByPersonDto', findPositionByPersonDto)
            const localVarPath = `/api/positions/position-by-person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findPositionByPersonDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePositionDto} findOnePositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsFindOne: async (id: string, findOnePositionDto: FindOnePositionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('positionsFindOne', 'id', id)
            // verify required parameter 'findOnePositionDto' is not null or undefined
            assertParamExists('positionsFindOne', 'findOnePositionDto', findOnePositionDto)
            const localVarPath = `/api/positions/find/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findOnePositionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a Position record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('positionsRemove', 'id', id)
            const localVarPath = `/api/positions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Position record
         * @param {string} id 
         * @param {UpdatePositionDto} updatePositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsUpdate: async (id: string, updatePositionDto: UpdatePositionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('positionsUpdate', 'id', id)
            // verify required parameter 'updatePositionDto' is not null or undefined
            assertParamExists('positionsUpdate', 'updatePositionDto', updatePositionDto)
            const localVarPath = `/api/positions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePositionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create role
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesCreate: async (createRoleDto: CreateRoleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoleDto' is not null or undefined
            assertParamExists('rolesCreate', 'createRoleDto', createRoleDto)
            const localVarPath = `/api/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rolesFindOne', 'id', id)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a role
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rolesRemove', 'id', id)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a company
         * @param {string} id 
         * @param {UpdateRoleDto} updateRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesUpdate: async (id: string, updateRoleDto: UpdateRoleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rolesUpdate', 'id', id)
            // verify required parameter 'updateRoleDto' is not null or undefined
            assertParamExists('rolesUpdate', 'updateRoleDto', updateRoleDto)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sseGetCompanyStream: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('sseGetCompanyStream', 'companyId', companyId)
            const localVarPath = `/api/server-events/company-stream/{companyId}`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create task
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreate: async (createTaskDto: CreateTaskDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskDto' is not null or undefined
            assertParamExists('tasksCreate', 'createTaskDto', createTaskDto)
            const localVarPath = `/api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindAllTaskDto} findAllTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksFindAll: async (findAllTaskDto: FindAllTaskDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findAllTaskDto' is not null or undefined
            assertParamExists('tasksFindAll', 'findAllTaskDto', findAllTaskDto)
            const localVarPath = `/api/tasks/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findAllTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOneTaskDto} findOneTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksFindOne: async (id: string, findOneTaskDto: FindOneTaskDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksFindOne', 'id', id)
            // verify required parameter 'findOneTaskDto' is not null or undefined
            assertParamExists('tasksFindOne', 'findOneTaskDto', findOneTaskDto)
            const localVarPath = `/api/tasks/find/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findOneTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a task
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRemove', 'id', id)
            const localVarPath = `/api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a task
         * @param {string} id 
         * @param {UpdateTaskDto} updateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksUpdate: async (id: string, updateTaskDto: UpdateTaskDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksUpdate', 'id', id)
            // verify required parameter 'updateTaskDto' is not null or undefined
            assertParamExists('tasksUpdate', 'updateTaskDto', updateTaskDto)
            const localVarPath = `/api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCompaniesCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindAllUserCompanyDto} findAllUserCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCompaniesFindAll: async (findAllUserCompanyDto: FindAllUserCompanyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findAllUserCompanyDto' is not null or undefined
            assertParamExists('userCompaniesFindAll', 'findAllUserCompanyDto', findAllUserCompanyDto)
            const localVarPath = `/api/user-companies/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findAllUserCompanyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOneUserCompanyDto} findOneUserCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCompaniesFindOne: async (id: string, findOneUserCompanyDto: FindOneUserCompanyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCompaniesFindOne', 'id', id)
            // verify required parameter 'findOneUserCompanyDto' is not null or undefined
            assertParamExists('userCompaniesFindOne', 'findOneUserCompanyDto', findOneUserCompanyDto)
            const localVarPath = `/api/user-companies/find/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findOneUserCompanyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a User Company record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCompaniesRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCompaniesRemove', 'id', id)
            const localVarPath = `/api/user-companies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a User Company record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCompaniesRestore: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCompaniesRestore', 'id', id)
            const localVarPath = `/api/user-companies/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate: async (createUserDto: CreateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('usersCreate', 'createUserDto', createUserDto)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} relations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFindAll: async (relations: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relations' is not null or undefined
            assertParamExists('usersFindAll', 'relations', relations)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (relations !== undefined) {
                localVarQueryParameter['relations'] = relations;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindOneUserDto} findOneUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFindCurrent: async (findOneUserDto: FindOneUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findOneUserDto' is not null or undefined
            assertParamExists('usersFindCurrent', 'findOneUserDto', findOneUserDto)
            const localVarPath = `/api/users/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findOneUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} relations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFindOne: async (id: string, relations: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersFindOne', 'id', id)
            // verify required parameter 'relations' is not null or undefined
            assertParamExists('usersFindOne', 'relations', relations)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (relations !== undefined) {
                localVarQueryParameter['relations'] = relations;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRemove', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user
         * @param {string} id 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (id: string, updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUpdate', 'id', id)
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('usersUpdate', 'updateUserDto', updateUserDto)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Work Norm record
         * @param {CreateWorkTimeNormDto} createWorkTimeNormDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTimeNormCreate: async (createWorkTimeNormDto: CreateWorkTimeNormDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkTimeNormDto' is not null or undefined
            assertParamExists('workTimeNormCreate', 'createWorkTimeNormDto', createWorkTimeNormDto)
            const localVarPath = `/api/work-time-norms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkTimeNormDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FindWorkTimeNormDto} findWorkTimeNormDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTimeNormFindAll: async (findWorkTimeNormDto: FindWorkTimeNormDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findWorkTimeNormDto' is not null or undefined
            assertParamExists('workTimeNormFindAll', 'findWorkTimeNormDto', findWorkTimeNormDto)
            const localVarPath = `/api/work-time-norms/find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findWorkTimeNormDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {FindWorkTimeNormDto} findWorkTimeNormDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTimeNormFindOne: async (id: string, findWorkTimeNormDto: FindWorkTimeNormDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workTimeNormFindOne', 'id', id)
            // verify required parameter 'findWorkTimeNormDto' is not null or undefined
            assertParamExists('workTimeNormFindOne', 'findWorkTimeNormDto', findWorkTimeNormDto)
            const localVarPath = `/api/work-time-norms/find/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findWorkTimeNormDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a Work Norm record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTimeNormRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workTimeNormRemove', 'id', id)
            const localVarPath = `/api/work-time-norms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Work Norm record
         * @param {string} id 
         * @param {UpdateWorkTimeNormDto} updateWorkTimeNormDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTimeNormUpdate: async (id: string, updateWorkTimeNormDto: UpdateWorkTimeNormDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workTimeNormUpdate', 'id', id)
            // verify required parameter 'updateWorkTimeNormDto' is not null or undefined
            assertParamExists('workTimeNormUpdate', 'updateWorkTimeNormDto', updateWorkTimeNormDto)
            const localVarPath = `/api/work-time-norms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkTimeNormDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check access
         * @param {AvailableAccessDto} availableAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessAvailable(availableAccessDto: AvailableAccessDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessAvailable(availableAccessDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.accessAvailable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check access for user
         * @param {AvailableAccessUserDto} availableAccessUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessAvailableForUser(availableAccessUserDto: AvailableAccessUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessAvailableForUser(availableAccessUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.accessAvailableForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check access for user in a company
         * @param {AvailableAccessUserCompanyDto} availableAccessUserCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessAvailableForUserCompany(availableAccessUserCompanyDto: AvailableAccessUserCompanyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessAvailableForUserCompany(availableAccessUserCompanyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.accessAvailableForUserCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an access record
         * @param {CreateAccessDto} createAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessCreate(createAccessDto: CreateAccessDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Access>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessCreate(createAccessDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.accessCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roleType 
         * @param {string} resource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessFindAll(roleType: string, resource: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Access>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessFindAll(roleType, resource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.accessFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Access>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.accessFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete an access record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Access>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.accessRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an access record
         * @param {string} id 
         * @param {UpdateAccessDto} updateAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessUpdate(id: string, updateAccessDto: UpdateAccessDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Access>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessUpdate(id, updateAccessDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.accessUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountingFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Accounting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountingFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.accountingFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountingFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Accounting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountingFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.accountingFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} lng 
         * @param {string} ns 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appAddLocales(lng: string, ns: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appAddLocales(lng, ns, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appAddLocales']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appGetHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appGetHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appGetHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} lang 
         * @param {string} ns 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appGetLocales(lang: string, ns: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appGetLocales(lang, ns, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appGetLocales']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appGetTitle(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appGetTitle(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appGetTitle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get response for a health checker
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appPing(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appPing(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appPing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDemo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDemo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authDemo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthDto} authDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogin(authDto: AuthDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogin(authDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefreshTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authRefreshTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegister(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegister(createUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create company
         * @param {CreateCompanyDto} createCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companiesCreate(createCompanyDto: CreateCompanyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companiesCreate(createCompanyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.companiesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companiesFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Company>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companiesFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.companiesFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companiesFindLast(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companiesFindLast(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.companiesFindLast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companiesFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companiesFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.companiesFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a company
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companiesRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companiesRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.companiesRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Calculate salary for a company
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companiesSalaryCalculate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companiesSalaryCalculate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.companiesSalaryCalculate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a company
         * @param {string} id 
         * @param {UpdateCompanyDto} updateCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companiesUpdate(id: string, updateCompanyDto: UpdateCompanyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companiesUpdate(id, updateCompanyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.companiesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create department
         * @param {CreateDepartmentDto} createDepartmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsCreate(createDepartmentDto: CreateDepartmentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Department>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsCreate(createDepartmentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.departmentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindAllDepartmentDto} findAllDepartmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsFindAll(findAllDepartmentDto: FindAllDepartmentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Department>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsFindAll(findAllDepartmentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.departmentsFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOneDepartmentDto} findOneDepartmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsFindOne(id: string, findOneDepartmentDto: FindOneDepartmentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Department>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsFindOne(id, findOneDepartmentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.departmentsFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a department
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Department>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.departmentsRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a department
         * @param {string} id 
         * @param {UpdateDepartmentDto} updateDepartmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsUpdate(id: string, updateDepartmentDto: UpdateDepartmentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Department>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsUpdate(id, updateDepartmentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.departmentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create job
         * @param {CreateJobDto} createJobDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsCreate(createJobDto: CreateJobDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsCreate(createJobDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.jobsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Job>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.jobsFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.jobsFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.jobsRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a job
         * @param {string} id 
         * @param {UpdateJobDto} updateJobDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsUpdate(id: string, updateJobDto: UpdateJobDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsUpdate(id, updateJobDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.jobsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lawsFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Law>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lawsFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.lawsFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lawsFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Law>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lawsFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.lawsFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async minWageFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MinWage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.minWageFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.minWageFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async minWageFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MinWage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.minWageFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.minWageFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a Min Wage record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async minWageRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MinWage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.minWageRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.minWageRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Min Wage record
         * @param {string} id 
         * @param {UpdateMinWageDto} updateMinWageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async minWageUpdate(id: string, updateMinWageDto: UpdateMinWageDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MinWage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.minWageUpdate(id, updateMinWageDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.minWageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Pay Fund Type record
         * @param {CreatePayFundTypeDto} createPayFundTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payFundTypesCreate(createPayFundTypeDto: CreatePayFundTypeDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayFundType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payFundTypesCreate(createPayFundTypeDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payFundTypesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payFundTypesFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PayFundType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payFundTypesFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payFundTypesFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payFundTypesFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayFundType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payFundTypesFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payFundTypesFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a Pay Fund Type record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payFundTypesRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayFundType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payFundTypesRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payFundTypesRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Pay Fund Type record
         * @param {string} id 
         * @param {UpdatePayFundTypeDto} updatePayFundTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payFundTypesUpdate(id: string, updatePayFundTypeDto: UpdatePayFundTypeDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayFundType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payFundTypesUpdate(id, updatePayFundTypeDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payFundTypesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a Pay Fund record
         * @param {CreatePayFundDto} createPayFundDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payFundsCreate(createPayFundDto: CreatePayFundDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayFund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payFundsCreate(createPayFundDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payFundsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindPayFundDto} findPayFundDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payFundsFindAll(findPayFundDto: FindPayFundDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PayFund>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payFundsFindAll(findPayFundDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payFundsFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} relations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payFundsFindOne(id: string, relations: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PayFund>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payFundsFindOne(id, relations, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payFundsFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Pay Fund record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payFundsRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayFund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payFundsRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payFundsRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdatePayFundDto} updatePayFundDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payFundsUpdate(id: string, updatePayFundDto: UpdatePayFundDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayFund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payFundsUpdate(id, updatePayFundDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payFundsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Close Pay Period
         * @param {string} id 
         * @param {ClosePayPeriodDto} closePayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payPeriodsClose(id: string, closePayPeriodDto: ClosePayPeriodDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayPeriod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payPeriodsClose(id, closePayPeriodDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payPeriodsClose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a Pay Period record
         * @param {CreatePayPeriodDto} createPayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payPeriodsCreate(createPayPeriodDto: CreatePayPeriodDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayPeriod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payPeriodsCreate(createPayPeriodDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payPeriodsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindAllPayPeriodDto} findAllPayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payPeriodsFindAll(findAllPayPeriodDto: FindAllPayPeriodDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PayPeriod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payPeriodsFindAll(findAllPayPeriodDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payPeriodsFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindCurrentPayPeriodDto} findCurrentPayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payPeriodsFindCurrent(findCurrentPayPeriodDto: FindCurrentPayPeriodDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayPeriod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payPeriodsFindCurrent(findCurrentPayPeriodDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payPeriodsFindCurrent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePayPeriodDto} findOnePayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payPeriodsFindOne(id: string, findOnePayPeriodDto: FindOnePayPeriodDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayPeriod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payPeriodsFindOne(id, findOnePayPeriodDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payPeriodsFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Open Pay Period
         * @param {string} id 
         * @param {OpenPayPeriodDto} openPayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payPeriodsOpen(id: string, openPayPeriodDto: OpenPayPeriodDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayPeriod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payPeriodsOpen(id, openPayPeriodDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payPeriodsOpen']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a Pay Period record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payPeriodsRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayPeriod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payPeriodsRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payPeriodsRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Pay Period record
         * @param {string} id 
         * @param {UpdatePayPeriodDto} updatePayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payPeriodsUpdate(id: string, updatePayPeriodDto: UpdatePayPeriodDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayPeriod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payPeriodsUpdate(id, updatePayPeriodDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payPeriodsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a Payment Position record
         * @param {CreatePaymentPositionDto} createPaymentPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentPositionsCreate(createPaymentPositionDto: CreatePaymentPositionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentPositionsCreate(createPaymentPositionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentPositionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindAllPaymentPositionDto} findAllPaymentPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentPositionsFindAll(findAllPaymentPositionDto: FindAllPaymentPositionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentPositionsFindAll(findAllPaymentPositionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentPositionsFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePaymentPositionDto} findOnePaymentPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentPositionsFindOne(id: string, findOnePaymentPositionDto: FindOnePaymentPositionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentPositionsFindOne(id, findOnePaymentPositionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentPositionsFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a Payment Position record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentPositionsRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentPositionsRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentPositionsRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Payment Position record
         * @param {string} id 
         * @param {UpdatePaymentPositionDto} updatePaymentPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentPositionsUpdate(id: string, updatePaymentPositionDto: UpdatePaymentPositionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentPositionsUpdate(id, updatePaymentPositionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentPositionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a Payment Type record
         * @param {CreatePaymentTypeDto} createPaymentTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentTypesCreate(createPaymentTypeDto: CreatePaymentTypeDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentTypesCreate(createPaymentTypeDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentTypesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindAllPaymentTypeDto} findAllPaymentTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentTypesFindAll(findAllPaymentTypeDto: FindAllPaymentTypeDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentTypesFindAll(findAllPaymentTypeDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentTypesFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentTypesFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentTypesFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentTypesFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a Payment Type record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentTypesRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentTypesRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentTypesRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Payment Type record
         * @param {string} id 
         * @param {UpdatePaymentTypeDto} updatePaymentTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentTypesUpdate(id: string, updatePaymentTypeDto: UpdatePaymentTypeDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentTypesUpdate(id, updatePaymentTypeDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentTypesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create payment
         * @param {CreatePaymentDto} createPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsCreate(createPaymentDto: CreatePaymentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsCreate(createPaymentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindAllPaymentDto} findAllPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsFindAll(findAllPaymentDto: FindAllPaymentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsFindAll(findAllPaymentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentsFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePaymentDto} findOnePaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsFindOne(id: string, findOnePaymentDto: FindOnePaymentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsFindOne(id, findOnePaymentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentsFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Process payment
         * @param {string} id 
         * @param {ProcessPaymentDto} processPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsProcess(id: string, processPaymentDto: ProcessPaymentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsProcess(id, processPaymentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentsProcess']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a payment record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentsRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore the deleted payment record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsRestore(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsRestore(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentsRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update payment
         * @param {string} id 
         * @param {UpdatePaymentDto} updatePaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsUpdate(id: string, updatePaymentDto: UpdatePaymentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsUpdate(id, updatePaymentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Withdraw payment
         * @param {string} id 
         * @param {WithdrawPaymentDto} withdrawPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsWithdraw(id: string, withdrawPaymentDto: WithdrawPaymentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsWithdraw(id, withdrawPaymentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.paymentsWithdraw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create payroll
         * @param {CreatePayrollDto} createPayrollDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsCreate(createPayrollDto: CreatePayrollDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payroll>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsCreate(createPayrollDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payrollsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindPayrollDto} findPayrollDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsFindAll(findPayrollDto: FindPayrollDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payroll>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsFindAll(findPayrollDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payrollsFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} relations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsFindOne(id: string, relations: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payroll>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsFindOne(id, relations, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payrollsFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete payroll
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payroll>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payrollsRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update payroll
         * @param {string} id 
         * @param {UpdatePayrollDto} updatePayrollDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsUpdate(id: string, updatePayrollDto: UpdatePayrollDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payroll>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsUpdate(id, updatePayrollDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.payrollsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a Person record
         * @param {CreatePersonDto} createPersonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personsCreate(createPersonDto: CreatePersonDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personsCreate(createPersonDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.personsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personsFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Person>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personsFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.personsFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personsFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personsFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.personsFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a Person record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personsRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personsRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.personsRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Person record
         * @param {string} id 
         * @param {UpdatePersonDto} updatePersonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personsUpdate(id: string, updatePersonDto: UpdatePersonDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personsUpdate(id, updatePersonDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.personsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Position History record
         * @param {CreatePositionHistoryDto} createPositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionHistoryCreate(createPositionHistoryDto: CreatePositionHistoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionHistoryCreate(createPositionHistoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionHistoryCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindAllPositionHistoryDto} findAllPositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionHistoryFindAll(findAllPositionHistoryDto: FindAllPositionHistoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PositionHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionHistoryFindAll(findAllPositionHistoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionHistoryFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindAllPositionHistoryDto} findAllPositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionHistoryFindLast(findAllPositionHistoryDto: FindAllPositionHistoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionHistoryFindLast(findAllPositionHistoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionHistoryFindLast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePositionHistoryDto} findOnePositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionHistoryFindOne(id: string, findOnePositionHistoryDto: FindOnePositionHistoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionHistoryFindOne(id, findOnePositionHistoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionHistoryFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a Position History record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionHistoryRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionHistoryRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionHistoryRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Position History record
         * @param {string} id 
         * @param {UpdatePositionHistoryDto} updatePositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionHistoryUpdate(id: string, updatePositionHistoryDto: UpdatePositionHistoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionHistoryUpdate(id, updatePositionHistoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionHistoryUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Position record
         * @param {CreatePositionDto} createPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionsCreate(createPositionDto: CreatePositionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionsCreate(createPositionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindAllPositionDto} findAllPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionsFindAll(findAllPositionDto: FindAllPositionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Position>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionsFindAll(findAllPositionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionsFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindAllPositionBalanceDto} findAllPositionBalanceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionsFindBalance(findAllPositionBalanceDto: FindAllPositionBalanceDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PositionBalanceExtendedDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionsFindBalance(findAllPositionBalanceDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionsFindBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindPositionByPersonDto} findPositionByPersonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionsFindFirstByPersonId(findPositionByPersonDto: FindPositionByPersonDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionsFindFirstByPersonId(findPositionByPersonDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionsFindFirstByPersonId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePositionDto} findOnePositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionsFindOne(id: string, findOnePositionDto: FindOnePositionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionsFindOne(id, findOnePositionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionsFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a Position record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionsRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionsRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionsRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Position record
         * @param {string} id 
         * @param {UpdatePositionDto} updatePositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionsUpdate(id: string, updatePositionDto: UpdatePositionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionsUpdate(id, updatePositionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.positionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create role
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesCreate(createRoleDto: CreateRoleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesCreate(createRoleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rolesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rolesFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rolesFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a role
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rolesRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a company
         * @param {string} id 
         * @param {UpdateRoleDto} updateRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesUpdate(id: string, updateRoleDto: UpdateRoleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesUpdate(id, updateRoleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rolesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sseGetCompanyStream(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sseGetCompanyStream(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sseGetCompanyStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create task
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreate(createTaskDto: CreateTaskDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCreate(createTaskDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.tasksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindAllTaskDto} findAllTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksFindAll(findAllTaskDto: FindAllTaskDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksFindAll(findAllTaskDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.tasksFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOneTaskDto} findOneTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksFindOne(id: string, findOneTaskDto: FindOneTaskDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksFindOne(id, findOneTaskDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.tasksFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a task
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.tasksRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a task
         * @param {string} id 
         * @param {UpdateTaskDto} updateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksUpdate(id: string, updateTaskDto: UpdateTaskDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksUpdate(id, updateTaskDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.tasksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCompaniesCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCompany>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCompaniesCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userCompaniesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindAllUserCompanyDto} findAllUserCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCompaniesFindAll(findAllUserCompanyDto: FindAllUserCompanyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCompany>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCompaniesFindAll(findAllUserCompanyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userCompaniesFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOneUserCompanyDto} findOneUserCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCompaniesFindOne(id: string, findOneUserCompanyDto: FindOneUserCompanyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCompaniesFindOne(id, findOneUserCompanyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userCompaniesFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a User Company record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCompaniesRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCompany>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCompaniesRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userCompaniesRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore a User Company record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCompaniesRestore(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCompany>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCompaniesRestore(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userCompaniesRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicUserDataDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreate(createUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.usersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} relations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersFindAll(relations: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersFindAll(relations, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.usersFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindOneUserDto} findOneUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersFindCurrent(findOneUserDto: FindOneUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersFindCurrent(findOneUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.usersFindCurrent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} relations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersFindOne(id: string, relations: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersFindOne(id, relations, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.usersFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicUserDataDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.usersRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user
         * @param {string} id 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(id: string, updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(id, updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.usersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Work Norm record
         * @param {CreateWorkTimeNormDto} createWorkTimeNormDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTimeNormCreate(createWorkTimeNormDto: CreateWorkTimeNormDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkTimeNorm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTimeNormCreate(createWorkTimeNormDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.workTimeNormCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FindWorkTimeNormDto} findWorkTimeNormDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTimeNormFindAll(findWorkTimeNormDto: FindWorkTimeNormDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkTimeNorm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTimeNormFindAll(findWorkTimeNormDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.workTimeNormFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {FindWorkTimeNormDto} findWorkTimeNormDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTimeNormFindOne(id: string, findWorkTimeNormDto: FindWorkTimeNormDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkTimeNorm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTimeNormFindOne(id, findWorkTimeNormDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.workTimeNormFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a Work Norm record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTimeNormRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkTimeNorm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTimeNormRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.workTimeNormRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Work Norm record
         * @param {string} id 
         * @param {UpdateWorkTimeNormDto} updateWorkTimeNormDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTimeNormUpdate(id: string, updateWorkTimeNormDto: UpdateWorkTimeNormDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkTimeNorm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTimeNormUpdate(id, updateWorkTimeNormDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.workTimeNormUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Check access
         * @param {AvailableAccessDto} availableAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessAvailable(availableAccessDto: AvailableAccessDto, options?: any): AxiosPromise<void> {
            return localVarFp.accessAvailable(availableAccessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check access for user
         * @param {AvailableAccessUserDto} availableAccessUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessAvailableForUser(availableAccessUserDto: AvailableAccessUserDto, options?: any): AxiosPromise<void> {
            return localVarFp.accessAvailableForUser(availableAccessUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check access for user in a company
         * @param {AvailableAccessUserCompanyDto} availableAccessUserCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessAvailableForUserCompany(availableAccessUserCompanyDto: AvailableAccessUserCompanyDto, options?: any): AxiosPromise<void> {
            return localVarFp.accessAvailableForUserCompany(availableAccessUserCompanyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an access record
         * @param {CreateAccessDto} createAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessCreate(createAccessDto: CreateAccessDto, options?: any): AxiosPromise<Access> {
            return localVarFp.accessCreate(createAccessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roleType 
         * @param {string} resource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessFindAll(roleType: string, resource: string, options?: any): AxiosPromise<Array<Access>> {
            return localVarFp.accessFindAll(roleType, resource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessFindOne(id: string, options?: any): AxiosPromise<Access> {
            return localVarFp.accessFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete an access record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessRemove(id: string, options?: any): AxiosPromise<Access> {
            return localVarFp.accessRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an access record
         * @param {string} id 
         * @param {UpdateAccessDto} updateAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessUpdate(id: string, updateAccessDto: UpdateAccessDto, options?: any): AxiosPromise<Access> {
            return localVarFp.accessUpdate(id, updateAccessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingFindAll(options?: any): AxiosPromise<Array<Accounting>> {
            return localVarFp.accountingFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingFindOne(id: string, options?: any): AxiosPromise<Accounting> {
            return localVarFp.accountingFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lng 
         * @param {string} ns 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAddLocales(lng: string, ns: string, options?: any): AxiosPromise<void> {
            return localVarFp.appAddLocales(lng, ns, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGetHello(options?: any): AxiosPromise<string> {
            return localVarFp.appGetHello(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lang 
         * @param {string} ns 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGetLocales(lang: string, ns: string, options?: any): AxiosPromise<void> {
            return localVarFp.appGetLocales(lang, ns, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGetTitle(options?: any): AxiosPromise<string> {
            return localVarFp.appGetTitle(options).then((request) => request(axios, basePath));
        },
        /**
         * Get response for a health checker
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPing(options?: any): AxiosPromise<string> {
            return localVarFp.appPing(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDemo(options?: any): AxiosPromise<AuthDto> {
            return localVarFp.authDemo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthDto} authDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin(authDto: AuthDto, options?: any): AxiosPromise<TokensDto> {
            return localVarFp.authLogin(authDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogout(options?: any): AxiosPromise<void> {
            return localVarFp.authLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshTokens(options?: any): AxiosPromise<TokensDto> {
            return localVarFp.authRefreshTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegister(createUserDto: CreateUserDto, options?: any): AxiosPromise<TokensDto> {
            return localVarFp.authRegister(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create company
         * @param {CreateCompanyDto} createCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesCreate(createCompanyDto: CreateCompanyDto, options?: any): AxiosPromise<Company> {
            return localVarFp.companiesCreate(createCompanyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesFindAll(options?: any): AxiosPromise<Array<Company>> {
            return localVarFp.companiesFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesFindLast(options?: any): AxiosPromise<Company> {
            return localVarFp.companiesFindLast(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesFindOne(id: string, options?: any): AxiosPromise<Company> {
            return localVarFp.companiesFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a company
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesRemove(id: string, options?: any): AxiosPromise<Company> {
            return localVarFp.companiesRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Calculate salary for a company
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesSalaryCalculate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.companiesSalaryCalculate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a company
         * @param {string} id 
         * @param {UpdateCompanyDto} updateCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesUpdate(id: string, updateCompanyDto: UpdateCompanyDto, options?: any): AxiosPromise<Company> {
            return localVarFp.companiesUpdate(id, updateCompanyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create department
         * @param {CreateDepartmentDto} createDepartmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsCreate(createDepartmentDto: CreateDepartmentDto, options?: any): AxiosPromise<Department> {
            return localVarFp.departmentsCreate(createDepartmentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindAllDepartmentDto} findAllDepartmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsFindAll(findAllDepartmentDto: FindAllDepartmentDto, options?: any): AxiosPromise<Array<Department>> {
            return localVarFp.departmentsFindAll(findAllDepartmentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOneDepartmentDto} findOneDepartmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsFindOne(id: string, findOneDepartmentDto: FindOneDepartmentDto, options?: any): AxiosPromise<Department> {
            return localVarFp.departmentsFindOne(id, findOneDepartmentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a department
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRemove(id: string, options?: any): AxiosPromise<Department> {
            return localVarFp.departmentsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a department
         * @param {string} id 
         * @param {UpdateDepartmentDto} updateDepartmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsUpdate(id: string, updateDepartmentDto: UpdateDepartmentDto, options?: any): AxiosPromise<Department> {
            return localVarFp.departmentsUpdate(id, updateDepartmentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create job
         * @param {CreateJobDto} createJobDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsCreate(createJobDto: CreateJobDto, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsCreate(createJobDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsFindAll(options?: any): AxiosPromise<Array<Job>> {
            return localVarFp.jobsFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsFindOne(id: string, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsRemove(id: string, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a job
         * @param {string} id 
         * @param {UpdateJobDto} updateJobDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsUpdate(id: string, updateJobDto: UpdateJobDto, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsUpdate(id, updateJobDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lawsFindAll(options?: any): AxiosPromise<Array<Law>> {
            return localVarFp.lawsFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lawsFindOne(id: string, options?: any): AxiosPromise<Law> {
            return localVarFp.lawsFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minWageFindAll(options?: any): AxiosPromise<Array<MinWage>> {
            return localVarFp.minWageFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minWageFindOne(id: string, options?: any): AxiosPromise<MinWage> {
            return localVarFp.minWageFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a Min Wage record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minWageRemove(id: string, options?: any): AxiosPromise<MinWage> {
            return localVarFp.minWageRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Min Wage record
         * @param {string} id 
         * @param {UpdateMinWageDto} updateMinWageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minWageUpdate(id: string, updateMinWageDto: UpdateMinWageDto, options?: any): AxiosPromise<MinWage> {
            return localVarFp.minWageUpdate(id, updateMinWageDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Pay Fund Type record
         * @param {CreatePayFundTypeDto} createPayFundTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundTypesCreate(createPayFundTypeDto: CreatePayFundTypeDto, options?: any): AxiosPromise<PayFundType> {
            return localVarFp.payFundTypesCreate(createPayFundTypeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundTypesFindAll(options?: any): AxiosPromise<Array<PayFundType>> {
            return localVarFp.payFundTypesFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundTypesFindOne(id: string, options?: any): AxiosPromise<PayFundType> {
            return localVarFp.payFundTypesFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a Pay Fund Type record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundTypesRemove(id: string, options?: any): AxiosPromise<PayFundType> {
            return localVarFp.payFundTypesRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Pay Fund Type record
         * @param {string} id 
         * @param {UpdatePayFundTypeDto} updatePayFundTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundTypesUpdate(id: string, updatePayFundTypeDto: UpdatePayFundTypeDto, options?: any): AxiosPromise<PayFundType> {
            return localVarFp.payFundTypesUpdate(id, updatePayFundTypeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Pay Fund record
         * @param {CreatePayFundDto} createPayFundDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundsCreate(createPayFundDto: CreatePayFundDto, options?: any): AxiosPromise<PayFund> {
            return localVarFp.payFundsCreate(createPayFundDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindPayFundDto} findPayFundDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundsFindAll(findPayFundDto: FindPayFundDto, options?: any): AxiosPromise<Array<PayFund>> {
            return localVarFp.payFundsFindAll(findPayFundDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} relations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundsFindOne(id: string, relations: boolean, options?: any): AxiosPromise<Array<PayFund>> {
            return localVarFp.payFundsFindOne(id, relations, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Pay Fund record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundsRemove(id: string, options?: any): AxiosPromise<PayFund> {
            return localVarFp.payFundsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdatePayFundDto} updatePayFundDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payFundsUpdate(id: string, updatePayFundDto: UpdatePayFundDto, options?: any): AxiosPromise<PayFund> {
            return localVarFp.payFundsUpdate(id, updatePayFundDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Close Pay Period
         * @param {string} id 
         * @param {ClosePayPeriodDto} closePayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsClose(id: string, closePayPeriodDto: ClosePayPeriodDto, options?: any): AxiosPromise<PayPeriod> {
            return localVarFp.payPeriodsClose(id, closePayPeriodDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Pay Period record
         * @param {CreatePayPeriodDto} createPayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsCreate(createPayPeriodDto: CreatePayPeriodDto, options?: any): AxiosPromise<PayPeriod> {
            return localVarFp.payPeriodsCreate(createPayPeriodDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindAllPayPeriodDto} findAllPayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsFindAll(findAllPayPeriodDto: FindAllPayPeriodDto, options?: any): AxiosPromise<Array<PayPeriod>> {
            return localVarFp.payPeriodsFindAll(findAllPayPeriodDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindCurrentPayPeriodDto} findCurrentPayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsFindCurrent(findCurrentPayPeriodDto: FindCurrentPayPeriodDto, options?: any): AxiosPromise<PayPeriod> {
            return localVarFp.payPeriodsFindCurrent(findCurrentPayPeriodDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePayPeriodDto} findOnePayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsFindOne(id: string, findOnePayPeriodDto: FindOnePayPeriodDto, options?: any): AxiosPromise<PayPeriod> {
            return localVarFp.payPeriodsFindOne(id, findOnePayPeriodDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Open Pay Period
         * @param {string} id 
         * @param {OpenPayPeriodDto} openPayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsOpen(id: string, openPayPeriodDto: OpenPayPeriodDto, options?: any): AxiosPromise<PayPeriod> {
            return localVarFp.payPeriodsOpen(id, openPayPeriodDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a Pay Period record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsRemove(id: string, options?: any): AxiosPromise<PayPeriod> {
            return localVarFp.payPeriodsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Pay Period record
         * @param {string} id 
         * @param {UpdatePayPeriodDto} updatePayPeriodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPeriodsUpdate(id: string, updatePayPeriodDto: UpdatePayPeriodDto, options?: any): AxiosPromise<PayPeriod> {
            return localVarFp.payPeriodsUpdate(id, updatePayPeriodDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Payment Position record
         * @param {CreatePaymentPositionDto} createPaymentPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPositionsCreate(createPaymentPositionDto: CreatePaymentPositionDto, options?: any): AxiosPromise<PaymentPosition> {
            return localVarFp.paymentPositionsCreate(createPaymentPositionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindAllPaymentPositionDto} findAllPaymentPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPositionsFindAll(findAllPaymentPositionDto: FindAllPaymentPositionDto, options?: any): AxiosPromise<Array<PaymentPosition>> {
            return localVarFp.paymentPositionsFindAll(findAllPaymentPositionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePaymentPositionDto} findOnePaymentPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPositionsFindOne(id: string, findOnePaymentPositionDto: FindOnePaymentPositionDto, options?: any): AxiosPromise<PaymentPosition> {
            return localVarFp.paymentPositionsFindOne(id, findOnePaymentPositionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a Payment Position record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPositionsRemove(id: string, options?: any): AxiosPromise<PaymentPosition> {
            return localVarFp.paymentPositionsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Payment Position record
         * @param {string} id 
         * @param {UpdatePaymentPositionDto} updatePaymentPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentPositionsUpdate(id: string, updatePaymentPositionDto: UpdatePaymentPositionDto, options?: any): AxiosPromise<PaymentPosition> {
            return localVarFp.paymentPositionsUpdate(id, updatePaymentPositionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Payment Type record
         * @param {CreatePaymentTypeDto} createPaymentTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypesCreate(createPaymentTypeDto: CreatePaymentTypeDto, options?: any): AxiosPromise<PaymentType> {
            return localVarFp.paymentTypesCreate(createPaymentTypeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindAllPaymentTypeDto} findAllPaymentTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypesFindAll(findAllPaymentTypeDto: FindAllPaymentTypeDto, options?: any): AxiosPromise<Array<PaymentType>> {
            return localVarFp.paymentTypesFindAll(findAllPaymentTypeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypesFindOne(id: string, options?: any): AxiosPromise<PaymentType> {
            return localVarFp.paymentTypesFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a Payment Type record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypesRemove(id: string, options?: any): AxiosPromise<PaymentType> {
            return localVarFp.paymentTypesRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Payment Type record
         * @param {string} id 
         * @param {UpdatePaymentTypeDto} updatePaymentTypeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypesUpdate(id: string, updatePaymentTypeDto: UpdatePaymentTypeDto, options?: any): AxiosPromise<PaymentType> {
            return localVarFp.paymentTypesUpdate(id, updatePaymentTypeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create payment
         * @param {CreatePaymentDto} createPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCreate(createPaymentDto: CreatePaymentDto, options?: any): AxiosPromise<Payment> {
            return localVarFp.paymentsCreate(createPaymentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindAllPaymentDto} findAllPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsFindAll(findAllPaymentDto: FindAllPaymentDto, options?: any): AxiosPromise<Array<Payment>> {
            return localVarFp.paymentsFindAll(findAllPaymentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePaymentDto} findOnePaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsFindOne(id: string, findOnePaymentDto: FindOnePaymentDto, options?: any): AxiosPromise<Payment> {
            return localVarFp.paymentsFindOne(id, findOnePaymentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Process payment
         * @param {string} id 
         * @param {ProcessPaymentDto} processPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsProcess(id: string, processPaymentDto: ProcessPaymentDto, options?: any): AxiosPromise<Payment> {
            return localVarFp.paymentsProcess(id, processPaymentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a payment record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsRemove(id: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.paymentsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore the deleted payment record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsRestore(id: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.paymentsRestore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update payment
         * @param {string} id 
         * @param {UpdatePaymentDto} updatePaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsUpdate(id: string, updatePaymentDto: UpdatePaymentDto, options?: any): AxiosPromise<Payment> {
            return localVarFp.paymentsUpdate(id, updatePaymentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Withdraw payment
         * @param {string} id 
         * @param {WithdrawPaymentDto} withdrawPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsWithdraw(id: string, withdrawPaymentDto: WithdrawPaymentDto, options?: any): AxiosPromise<Payment> {
            return localVarFp.paymentsWithdraw(id, withdrawPaymentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create payroll
         * @param {CreatePayrollDto} createPayrollDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsCreate(createPayrollDto: CreatePayrollDto, options?: any): AxiosPromise<Payroll> {
            return localVarFp.payrollsCreate(createPayrollDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindPayrollDto} findPayrollDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsFindAll(findPayrollDto: FindPayrollDto, options?: any): AxiosPromise<Array<Payroll>> {
            return localVarFp.payrollsFindAll(findPayrollDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} relations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsFindOne(id: string, relations: boolean, options?: any): AxiosPromise<Payroll> {
            return localVarFp.payrollsFindOne(id, relations, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete payroll
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsRemove(id: string, options?: any): AxiosPromise<Payroll> {
            return localVarFp.payrollsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update payroll
         * @param {string} id 
         * @param {UpdatePayrollDto} updatePayrollDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsUpdate(id: string, updatePayrollDto: UpdatePayrollDto, options?: any): AxiosPromise<Payroll> {
            return localVarFp.payrollsUpdate(id, updatePayrollDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Person record
         * @param {CreatePersonDto} createPersonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personsCreate(createPersonDto: CreatePersonDto, options?: any): AxiosPromise<Person> {
            return localVarFp.personsCreate(createPersonDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personsFindAll(options?: any): AxiosPromise<Array<Person>> {
            return localVarFp.personsFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personsFindOne(id: string, options?: any): AxiosPromise<Person> {
            return localVarFp.personsFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a Person record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personsRemove(id: string, options?: any): AxiosPromise<Person> {
            return localVarFp.personsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Person record
         * @param {string} id 
         * @param {UpdatePersonDto} updatePersonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personsUpdate(id: string, updatePersonDto: UpdatePersonDto, options?: any): AxiosPromise<Person> {
            return localVarFp.personsUpdate(id, updatePersonDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Position History record
         * @param {CreatePositionHistoryDto} createPositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionHistoryCreate(createPositionHistoryDto: CreatePositionHistoryDto, options?: any): AxiosPromise<PositionHistory> {
            return localVarFp.positionHistoryCreate(createPositionHistoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindAllPositionHistoryDto} findAllPositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionHistoryFindAll(findAllPositionHistoryDto: FindAllPositionHistoryDto, options?: any): AxiosPromise<Array<PositionHistory>> {
            return localVarFp.positionHistoryFindAll(findAllPositionHistoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindAllPositionHistoryDto} findAllPositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionHistoryFindLast(findAllPositionHistoryDto: FindAllPositionHistoryDto, options?: any): AxiosPromise<PositionHistory> {
            return localVarFp.positionHistoryFindLast(findAllPositionHistoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePositionHistoryDto} findOnePositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionHistoryFindOne(id: string, findOnePositionHistoryDto: FindOnePositionHistoryDto, options?: any): AxiosPromise<PositionHistory> {
            return localVarFp.positionHistoryFindOne(id, findOnePositionHistoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a Position History record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionHistoryRemove(id: string, options?: any): AxiosPromise<PositionHistory> {
            return localVarFp.positionHistoryRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Position History record
         * @param {string} id 
         * @param {UpdatePositionHistoryDto} updatePositionHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionHistoryUpdate(id: string, updatePositionHistoryDto: UpdatePositionHistoryDto, options?: any): AxiosPromise<PositionHistory> {
            return localVarFp.positionHistoryUpdate(id, updatePositionHistoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Position record
         * @param {CreatePositionDto} createPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsCreate(createPositionDto: CreatePositionDto, options?: any): AxiosPromise<Position> {
            return localVarFp.positionsCreate(createPositionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindAllPositionDto} findAllPositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsFindAll(findAllPositionDto: FindAllPositionDto, options?: any): AxiosPromise<Array<Position>> {
            return localVarFp.positionsFindAll(findAllPositionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindAllPositionBalanceDto} findAllPositionBalanceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsFindBalance(findAllPositionBalanceDto: FindAllPositionBalanceDto, options?: any): AxiosPromise<Array<PositionBalanceExtendedDto>> {
            return localVarFp.positionsFindBalance(findAllPositionBalanceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindPositionByPersonDto} findPositionByPersonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsFindFirstByPersonId(findPositionByPersonDto: FindPositionByPersonDto, options?: any): AxiosPromise<Position> {
            return localVarFp.positionsFindFirstByPersonId(findPositionByPersonDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOnePositionDto} findOnePositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsFindOne(id: string, findOnePositionDto: FindOnePositionDto, options?: any): AxiosPromise<Position> {
            return localVarFp.positionsFindOne(id, findOnePositionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a Position record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsRemove(id: string, options?: any): AxiosPromise<Position> {
            return localVarFp.positionsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Position record
         * @param {string} id 
         * @param {UpdatePositionDto} updatePositionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsUpdate(id: string, updatePositionDto: UpdatePositionDto, options?: any): AxiosPromise<Position> {
            return localVarFp.positionsUpdate(id, updatePositionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create role
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesCreate(createRoleDto: CreateRoleDto, options?: any): AxiosPromise<Role> {
            return localVarFp.rolesCreate(createRoleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesFindAll(options?: any): AxiosPromise<Array<Role>> {
            return localVarFp.rolesFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesFindOne(id: string, options?: any): AxiosPromise<Role> {
            return localVarFp.rolesFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a role
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesRemove(id: string, options?: any): AxiosPromise<Role> {
            return localVarFp.rolesRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a company
         * @param {string} id 
         * @param {UpdateRoleDto} updateRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesUpdate(id: string, updateRoleDto: UpdateRoleDto, options?: any): AxiosPromise<Role> {
            return localVarFp.rolesUpdate(id, updateRoleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sseGetCompanyStream(companyId: string, options?: any): AxiosPromise<MessageEvent> {
            return localVarFp.sseGetCompanyStream(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create task
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreate(createTaskDto: CreateTaskDto, options?: any): AxiosPromise<Task> {
            return localVarFp.tasksCreate(createTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindAllTaskDto} findAllTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksFindAll(findAllTaskDto: FindAllTaskDto, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.tasksFindAll(findAllTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOneTaskDto} findOneTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksFindOne(id: string, findOneTaskDto: FindOneTaskDto, options?: any): AxiosPromise<Task> {
            return localVarFp.tasksFindOne(id, findOneTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a task
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRemove(id: string, options?: any): AxiosPromise<Task> {
            return localVarFp.tasksRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a task
         * @param {string} id 
         * @param {UpdateTaskDto} updateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksUpdate(id: string, updateTaskDto: UpdateTaskDto, options?: any): AxiosPromise<Task> {
            return localVarFp.tasksUpdate(id, updateTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCompaniesCreate(options?: any): AxiosPromise<Array<UserCompany>> {
            return localVarFp.userCompaniesCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindAllUserCompanyDto} findAllUserCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCompaniesFindAll(findAllUserCompanyDto: FindAllUserCompanyDto, options?: any): AxiosPromise<Array<UserCompany>> {
            return localVarFp.userCompaniesFindAll(findAllUserCompanyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {FindOneUserCompanyDto} findOneUserCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCompaniesFindOne(id: string, findOneUserCompanyDto: FindOneUserCompanyDto, options?: any): AxiosPromise<void> {
            return localVarFp.userCompaniesFindOne(id, findOneUserCompanyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a User Company record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCompaniesRemove(id: string, options?: any): AxiosPromise<UserCompany> {
            return localVarFp.userCompaniesRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a User Company record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCompaniesRestore(id: string, options?: any): AxiosPromise<UserCompany> {
            return localVarFp.userCompaniesRestore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate(createUserDto: CreateUserDto, options?: any): AxiosPromise<PublicUserDataDto> {
            return localVarFp.usersCreate(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} relations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFindAll(relations: boolean, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.usersFindAll(relations, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindOneUserDto} findOneUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFindCurrent(findOneUserDto: FindOneUserDto, options?: any): AxiosPromise<User> {
            return localVarFp.usersFindCurrent(findOneUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} relations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFindOne(id: string, relations: boolean, options?: any): AxiosPromise<User> {
            return localVarFp.usersFindOne(id, relations, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRemove(id: string, options?: any): AxiosPromise<PublicUserDataDto> {
            return localVarFp.usersRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user
         * @param {string} id 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id: string, updateUserDto: UpdateUserDto, options?: any): AxiosPromise<User> {
            return localVarFp.usersUpdate(id, updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Work Norm record
         * @param {CreateWorkTimeNormDto} createWorkTimeNormDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTimeNormCreate(createWorkTimeNormDto: CreateWorkTimeNormDto, options?: any): AxiosPromise<WorkTimeNorm> {
            return localVarFp.workTimeNormCreate(createWorkTimeNormDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FindWorkTimeNormDto} findWorkTimeNormDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTimeNormFindAll(findWorkTimeNormDto: FindWorkTimeNormDto, options?: any): AxiosPromise<Array<WorkTimeNorm>> {
            return localVarFp.workTimeNormFindAll(findWorkTimeNormDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {FindWorkTimeNormDto} findWorkTimeNormDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTimeNormFindOne(id: string, findWorkTimeNormDto: FindWorkTimeNormDto, options?: any): AxiosPromise<WorkTimeNorm> {
            return localVarFp.workTimeNormFindOne(id, findWorkTimeNormDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a Work Norm record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTimeNormRemove(id: string, options?: any): AxiosPromise<WorkTimeNorm> {
            return localVarFp.workTimeNormRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Work Norm record
         * @param {string} id 
         * @param {UpdateWorkTimeNormDto} updateWorkTimeNormDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTimeNormUpdate(id: string, updateWorkTimeNormDto: UpdateWorkTimeNormDto, options?: any): AxiosPromise<WorkTimeNorm> {
            return localVarFp.workTimeNormUpdate(id, updateWorkTimeNormDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Check access
     * @param {AvailableAccessDto} availableAccessDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accessAvailable(availableAccessDto: AvailableAccessDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accessAvailable(availableAccessDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check access for user
     * @param {AvailableAccessUserDto} availableAccessUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accessAvailableForUser(availableAccessUserDto: AvailableAccessUserDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accessAvailableForUser(availableAccessUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check access for user in a company
     * @param {AvailableAccessUserCompanyDto} availableAccessUserCompanyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accessAvailableForUserCompany(availableAccessUserCompanyDto: AvailableAccessUserCompanyDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accessAvailableForUserCompany(availableAccessUserCompanyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an access record
     * @param {CreateAccessDto} createAccessDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accessCreate(createAccessDto: CreateAccessDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accessCreate(createAccessDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roleType 
     * @param {string} resource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accessFindAll(roleType: string, resource: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accessFindAll(roleType, resource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accessFindOne(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accessFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete an access record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accessRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accessRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an access record
     * @param {string} id 
     * @param {UpdateAccessDto} updateAccessDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accessUpdate(id: string, updateAccessDto: UpdateAccessDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accessUpdate(id, updateAccessDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountingFindAll(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountingFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountingFindOne(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountingFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lng 
     * @param {string} ns 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appAddLocales(lng: string, ns: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appAddLocales(lng, ns, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appGetHello(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appGetHello(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lang 
     * @param {string} ns 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appGetLocales(lang: string, ns: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appGetLocales(lang, ns, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appGetTitle(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appGetTitle(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get response for a health checker
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appPing(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appPing(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public authDemo(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authDemo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthDto} authDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public authLogin(authDto: AuthDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authLogin(authDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public authLogout(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public authRefreshTokens(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authRefreshTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public authRegister(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authRegister(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create company
     * @param {CreateCompanyDto} createCompanyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public companiesCreate(createCompanyDto: CreateCompanyDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).companiesCreate(createCompanyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public companiesFindAll(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).companiesFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public companiesFindLast(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).companiesFindLast(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public companiesFindOne(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).companiesFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a company
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public companiesRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).companiesRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Calculate salary for a company
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public companiesSalaryCalculate(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).companiesSalaryCalculate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a company
     * @param {string} id 
     * @param {UpdateCompanyDto} updateCompanyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public companiesUpdate(id: string, updateCompanyDto: UpdateCompanyDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).companiesUpdate(id, updateCompanyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create department
     * @param {CreateDepartmentDto} createDepartmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public departmentsCreate(createDepartmentDto: CreateDepartmentDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).departmentsCreate(createDepartmentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindAllDepartmentDto} findAllDepartmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public departmentsFindAll(findAllDepartmentDto: FindAllDepartmentDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).departmentsFindAll(findAllDepartmentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {FindOneDepartmentDto} findOneDepartmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public departmentsFindOne(id: string, findOneDepartmentDto: FindOneDepartmentDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).departmentsFindOne(id, findOneDepartmentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a department
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public departmentsRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).departmentsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a department
     * @param {string} id 
     * @param {UpdateDepartmentDto} updateDepartmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public departmentsUpdate(id: string, updateDepartmentDto: UpdateDepartmentDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).departmentsUpdate(id, updateDepartmentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create job
     * @param {CreateJobDto} createJobDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public jobsCreate(createJobDto: CreateJobDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).jobsCreate(createJobDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public jobsFindAll(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).jobsFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public jobsFindOne(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).jobsFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a job
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public jobsRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).jobsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a job
     * @param {string} id 
     * @param {UpdateJobDto} updateJobDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public jobsUpdate(id: string, updateJobDto: UpdateJobDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).jobsUpdate(id, updateJobDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lawsFindAll(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lawsFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lawsFindOne(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lawsFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public minWageFindAll(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).minWageFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public minWageFindOne(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).minWageFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a Min Wage record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public minWageRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).minWageRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Min Wage record
     * @param {string} id 
     * @param {UpdateMinWageDto} updateMinWageDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public minWageUpdate(id: string, updateMinWageDto: UpdateMinWageDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).minWageUpdate(id, updateMinWageDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Pay Fund Type record
     * @param {CreatePayFundTypeDto} createPayFundTypeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payFundTypesCreate(createPayFundTypeDto: CreatePayFundTypeDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payFundTypesCreate(createPayFundTypeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payFundTypesFindAll(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payFundTypesFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payFundTypesFindOne(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payFundTypesFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a Pay Fund Type record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payFundTypesRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payFundTypesRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Pay Fund Type record
     * @param {string} id 
     * @param {UpdatePayFundTypeDto} updatePayFundTypeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payFundTypesUpdate(id: string, updatePayFundTypeDto: UpdatePayFundTypeDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payFundTypesUpdate(id, updatePayFundTypeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Pay Fund record
     * @param {CreatePayFundDto} createPayFundDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payFundsCreate(createPayFundDto: CreatePayFundDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payFundsCreate(createPayFundDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindPayFundDto} findPayFundDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payFundsFindAll(findPayFundDto: FindPayFundDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payFundsFindAll(findPayFundDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {boolean} relations 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payFundsFindOne(id: string, relations: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payFundsFindOne(id, relations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Pay Fund record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payFundsRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payFundsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdatePayFundDto} updatePayFundDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payFundsUpdate(id: string, updatePayFundDto: UpdatePayFundDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payFundsUpdate(id, updatePayFundDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Close Pay Period
     * @param {string} id 
     * @param {ClosePayPeriodDto} closePayPeriodDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payPeriodsClose(id: string, closePayPeriodDto: ClosePayPeriodDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payPeriodsClose(id, closePayPeriodDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Pay Period record
     * @param {CreatePayPeriodDto} createPayPeriodDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payPeriodsCreate(createPayPeriodDto: CreatePayPeriodDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payPeriodsCreate(createPayPeriodDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindAllPayPeriodDto} findAllPayPeriodDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payPeriodsFindAll(findAllPayPeriodDto: FindAllPayPeriodDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payPeriodsFindAll(findAllPayPeriodDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindCurrentPayPeriodDto} findCurrentPayPeriodDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payPeriodsFindCurrent(findCurrentPayPeriodDto: FindCurrentPayPeriodDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payPeriodsFindCurrent(findCurrentPayPeriodDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {FindOnePayPeriodDto} findOnePayPeriodDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payPeriodsFindOne(id: string, findOnePayPeriodDto: FindOnePayPeriodDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payPeriodsFindOne(id, findOnePayPeriodDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Open Pay Period
     * @param {string} id 
     * @param {OpenPayPeriodDto} openPayPeriodDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payPeriodsOpen(id: string, openPayPeriodDto: OpenPayPeriodDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payPeriodsOpen(id, openPayPeriodDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a Pay Period record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payPeriodsRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payPeriodsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Pay Period record
     * @param {string} id 
     * @param {UpdatePayPeriodDto} updatePayPeriodDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payPeriodsUpdate(id: string, updatePayPeriodDto: UpdatePayPeriodDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payPeriodsUpdate(id, updatePayPeriodDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Payment Position record
     * @param {CreatePaymentPositionDto} createPaymentPositionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentPositionsCreate(createPaymentPositionDto: CreatePaymentPositionDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentPositionsCreate(createPaymentPositionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindAllPaymentPositionDto} findAllPaymentPositionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentPositionsFindAll(findAllPaymentPositionDto: FindAllPaymentPositionDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentPositionsFindAll(findAllPaymentPositionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {FindOnePaymentPositionDto} findOnePaymentPositionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentPositionsFindOne(id: string, findOnePaymentPositionDto: FindOnePaymentPositionDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentPositionsFindOne(id, findOnePaymentPositionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a Payment Position record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentPositionsRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentPositionsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Payment Position record
     * @param {string} id 
     * @param {UpdatePaymentPositionDto} updatePaymentPositionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentPositionsUpdate(id: string, updatePaymentPositionDto: UpdatePaymentPositionDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentPositionsUpdate(id, updatePaymentPositionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Payment Type record
     * @param {CreatePaymentTypeDto} createPaymentTypeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentTypesCreate(createPaymentTypeDto: CreatePaymentTypeDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentTypesCreate(createPaymentTypeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindAllPaymentTypeDto} findAllPaymentTypeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentTypesFindAll(findAllPaymentTypeDto: FindAllPaymentTypeDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentTypesFindAll(findAllPaymentTypeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentTypesFindOne(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentTypesFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a Payment Type record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentTypesRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentTypesRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Payment Type record
     * @param {string} id 
     * @param {UpdatePaymentTypeDto} updatePaymentTypeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentTypesUpdate(id: string, updatePaymentTypeDto: UpdatePaymentTypeDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentTypesUpdate(id, updatePaymentTypeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create payment
     * @param {CreatePaymentDto} createPaymentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentsCreate(createPaymentDto: CreatePaymentDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentsCreate(createPaymentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindAllPaymentDto} findAllPaymentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentsFindAll(findAllPaymentDto: FindAllPaymentDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentsFindAll(findAllPaymentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {FindOnePaymentDto} findOnePaymentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentsFindOne(id: string, findOnePaymentDto: FindOnePaymentDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentsFindOne(id, findOnePaymentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Process payment
     * @param {string} id 
     * @param {ProcessPaymentDto} processPaymentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentsProcess(id: string, processPaymentDto: ProcessPaymentDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentsProcess(id, processPaymentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a payment record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentsRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore the deleted payment record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentsRestore(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentsRestore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update payment
     * @param {string} id 
     * @param {UpdatePaymentDto} updatePaymentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentsUpdate(id: string, updatePaymentDto: UpdatePaymentDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentsUpdate(id, updatePaymentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Withdraw payment
     * @param {string} id 
     * @param {WithdrawPaymentDto} withdrawPaymentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public paymentsWithdraw(id: string, withdrawPaymentDto: WithdrawPaymentDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).paymentsWithdraw(id, withdrawPaymentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create payroll
     * @param {CreatePayrollDto} createPayrollDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payrollsCreate(createPayrollDto: CreatePayrollDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payrollsCreate(createPayrollDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindPayrollDto} findPayrollDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payrollsFindAll(findPayrollDto: FindPayrollDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payrollsFindAll(findPayrollDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {boolean} relations 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payrollsFindOne(id: string, relations: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payrollsFindOne(id, relations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete payroll
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payrollsRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payrollsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update payroll
     * @param {string} id 
     * @param {UpdatePayrollDto} updatePayrollDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payrollsUpdate(id: string, updatePayrollDto: UpdatePayrollDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payrollsUpdate(id, updatePayrollDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Person record
     * @param {CreatePersonDto} createPersonDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public personsCreate(createPersonDto: CreatePersonDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).personsCreate(createPersonDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public personsFindAll(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).personsFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public personsFindOne(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).personsFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a Person record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public personsRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).personsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Person record
     * @param {string} id 
     * @param {UpdatePersonDto} updatePersonDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public personsUpdate(id: string, updatePersonDto: UpdatePersonDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).personsUpdate(id, updatePersonDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Position History record
     * @param {CreatePositionHistoryDto} createPositionHistoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionHistoryCreate(createPositionHistoryDto: CreatePositionHistoryDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionHistoryCreate(createPositionHistoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindAllPositionHistoryDto} findAllPositionHistoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionHistoryFindAll(findAllPositionHistoryDto: FindAllPositionHistoryDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionHistoryFindAll(findAllPositionHistoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindAllPositionHistoryDto} findAllPositionHistoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionHistoryFindLast(findAllPositionHistoryDto: FindAllPositionHistoryDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionHistoryFindLast(findAllPositionHistoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {FindOnePositionHistoryDto} findOnePositionHistoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionHistoryFindOne(id: string, findOnePositionHistoryDto: FindOnePositionHistoryDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionHistoryFindOne(id, findOnePositionHistoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a Position History record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionHistoryRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionHistoryRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Position History record
     * @param {string} id 
     * @param {UpdatePositionHistoryDto} updatePositionHistoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionHistoryUpdate(id: string, updatePositionHistoryDto: UpdatePositionHistoryDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionHistoryUpdate(id, updatePositionHistoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Position record
     * @param {CreatePositionDto} createPositionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionsCreate(createPositionDto: CreatePositionDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionsCreate(createPositionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindAllPositionDto} findAllPositionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionsFindAll(findAllPositionDto: FindAllPositionDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionsFindAll(findAllPositionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindAllPositionBalanceDto} findAllPositionBalanceDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionsFindBalance(findAllPositionBalanceDto: FindAllPositionBalanceDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionsFindBalance(findAllPositionBalanceDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindPositionByPersonDto} findPositionByPersonDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionsFindFirstByPersonId(findPositionByPersonDto: FindPositionByPersonDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionsFindFirstByPersonId(findPositionByPersonDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {FindOnePositionDto} findOnePositionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionsFindOne(id: string, findOnePositionDto: FindOnePositionDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionsFindOne(id, findOnePositionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a Position record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionsRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Position record
     * @param {string} id 
     * @param {UpdatePositionDto} updatePositionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public positionsUpdate(id: string, updatePositionDto: UpdatePositionDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).positionsUpdate(id, updatePositionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create role
     * @param {CreateRoleDto} createRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rolesCreate(createRoleDto: CreateRoleDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rolesCreate(createRoleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rolesFindAll(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rolesFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rolesFindOne(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rolesFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a role
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rolesRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rolesRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a company
     * @param {string} id 
     * @param {UpdateRoleDto} updateRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rolesUpdate(id: string, updateRoleDto: UpdateRoleDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rolesUpdate(id, updateRoleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sseGetCompanyStream(companyId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sseGetCompanyStream(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create task
     * @param {CreateTaskDto} createTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksCreate(createTaskDto: CreateTaskDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksCreate(createTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindAllTaskDto} findAllTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksFindAll(findAllTaskDto: FindAllTaskDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksFindAll(findAllTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {FindOneTaskDto} findOneTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksFindOne(id: string, findOneTaskDto: FindOneTaskDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksFindOne(id, findOneTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a task
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a task
     * @param {string} id 
     * @param {UpdateTaskDto} updateTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksUpdate(id: string, updateTaskDto: UpdateTaskDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksUpdate(id, updateTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userCompaniesCreate(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userCompaniesCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindAllUserCompanyDto} findAllUserCompanyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userCompaniesFindAll(findAllUserCompanyDto: FindAllUserCompanyDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userCompaniesFindAll(findAllUserCompanyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {FindOneUserCompanyDto} findOneUserCompanyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userCompaniesFindOne(id: string, findOneUserCompanyDto: FindOneUserCompanyDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userCompaniesFindOne(id, findOneUserCompanyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a User Company record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userCompaniesRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userCompaniesRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a User Company record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userCompaniesRestore(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userCompaniesRestore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a user
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).usersCreate(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} relations 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersFindAll(relations: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).usersFindAll(relations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindOneUserDto} findOneUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersFindCurrent(findOneUserDto: FindOneUserDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).usersFindCurrent(findOneUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {boolean} relations 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersFindOne(id: string, relations: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).usersFindOne(id, relations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).usersRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user
     * @param {string} id 
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersUpdate(id: string, updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).usersUpdate(id, updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Work Norm record
     * @param {CreateWorkTimeNormDto} createWorkTimeNormDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public workTimeNormCreate(createWorkTimeNormDto: CreateWorkTimeNormDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).workTimeNormCreate(createWorkTimeNormDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FindWorkTimeNormDto} findWorkTimeNormDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public workTimeNormFindAll(findWorkTimeNormDto: FindWorkTimeNormDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).workTimeNormFindAll(findWorkTimeNormDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {FindWorkTimeNormDto} findWorkTimeNormDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public workTimeNormFindOne(id: string, findWorkTimeNormDto: FindWorkTimeNormDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).workTimeNormFindOne(id, findWorkTimeNormDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a Work Norm record
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public workTimeNormRemove(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).workTimeNormRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Work Norm record
     * @param {string} id 
     * @param {UpdateWorkTimeNormDto} updateWorkTimeNormDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public workTimeNormUpdate(id: string, updateWorkTimeNormDto: UpdateWorkTimeNormDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).workTimeNormUpdate(id, updateWorkTimeNormDto, options).then((request) => request(this.axios, this.basePath));
    }
}



